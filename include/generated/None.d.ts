// THIS FILE IS GENERATED AUTOMATICALLY AND SHOULD NOT BE EDITED BY HAND!

/// <reference no-default-lib="true"/>
/// <reference path="../roblox.d.ts" />
/// <reference path="enums.d.ts" />

interface Services {
	ABTestService: ABTestService;
	AdService: AdService;
	AssetService: AssetService;
	BadgeService: BadgeService;
	CoreGui: CoreGui;
	StarterGui: StarterGui;
	BrowserService: BrowserService;
	CacheableContentProvider: CacheableContentProvider;
	MeshContentProvider: MeshContentProvider;
	SolidModelContentProvider: SolidModelContentProvider;
	ChangeHistoryService: ChangeHistoryService;
	Chat: Chat;
	ClusterPacketCache: ClusterPacketCache;
	CollectionService: CollectionService;
	ContentProvider: ContentProvider;
	ContextActionService: ContextActionService;
	ControllerService: ControllerService;
	CookiesService: CookiesService;
	CorePackages: CorePackages;
	CoreScriptSyncService: CoreScriptSyncService;
	DataStoreService: DataStoreService;
	Debris: Debris;
	FlagStandService: FlagStandService;
	FlyweightService: FlyweightService;
	CSGDictionaryService: CSGDictionaryService;
	NonReplicatedCSGDictionaryService: NonReplicatedCSGDictionaryService;
	FriendService: FriendService;
	GamePassService: GamePassService;
	GamepadService: GamepadService;
	Geometry: Geometry;
	GoogleAnalyticsConfiguration: GoogleAnalyticsConfiguration;
	GroupService: GroupService;
	GuiService: GuiService;
	GuidRegistryService: GuidRegistryService;
	HapticService: HapticService;
	Hopper: Hopper;
	HttpRbxApiService: HttpRbxApiService;
	HttpService: HttpService;
	InsertService: InsertService;
	JointsService: JointsService;
	KeyboardService: KeyboardService;
	KeyframeSequenceProvider: KeyframeSequenceProvider;
	Lighting: Lighting;
	LocalStorageService: LocalStorageService;
	AppStorageService: AppStorageService;
	UserStorageService: UserStorageService;
	LocalizationService: LocalizationService;
	LogService: LogService;
	LoginService: LoginService;
	LuaWebService: LuaWebService;
	MarketplaceService: MarketplaceService;
	MessagingService: MessagingService;
	MouseService: MouseService;
	NetworkClient: NetworkClient;
	NetworkServer: NetworkServer;
	NetworkSettings: NetworkSettings;
	NotificationService: NotificationService;
	Workspace: Workspace;
	PackageService: PackageService;
	PathfindingService: PathfindingService;
	PhysicsPacketCache: PhysicsPacketCache;
	PhysicsService: PhysicsService;
	Players: Players;
	PluginGuiService: PluginGuiService;
	PointsService: PointsService;
	RbxAnalyticsService: RbxAnalyticsService;
	RenderSettings: RenderSettings;
	ReplicatedFirst: ReplicatedFirst;
	ReplicatedStorage: ReplicatedStorage;
	RobloxPluginGuiService: RobloxPluginGuiService;
	RobloxReplicatedStorage: RobloxReplicatedStorage;
	RunService: RunService;
	RuntimeScriptService: RuntimeScriptService;
	ScriptContext: ScriptContext;
	ScriptService: ScriptService;
	Selection: Selection;
	ServerScriptService: ServerScriptService;
	ServerStorage: ServerStorage;
	SocialService: SocialService;
	SoundService: SoundService;
	SpawnerService: SpawnerService;
	StarterPack: StarterPack;
	StarterPlayer: StarterPlayer;
	Stats: Stats;
	StopWatchReporter: StopWatchReporter;
	Studio: Studio;
	StudioData: StudioData;
	StudioService: StudioService;
	TaskScheduler: TaskScheduler;
	Teams: Teams;
	TeleportService: TeleportService;
	TestService: TestService;
	TextService: TextService;
	ThirdPartyUserService: ThirdPartyUserService;
	TimerService: TimerService;
	TouchInputService: TouchInputService;
	TweenService: TweenService;
	UserGameSettings: UserGameSettings;
	UserInputService: UserInputService;
	VRService: VRService;
	VirtualInputManager: VirtualInputManager;
	VirtualUser: VirtualUser;
	Visit: Visit;
}

interface CreatableInstances {
	Accoutrement: Accoutrement;
	Accessory: Accessory;
	Hat: Hat;
	AdvancedDragger: AdvancedDragger;
	Animation: Animation;
	AnimationController: AnimationController;
	Animator: Animator;
	Attachment: Attachment;
	Backpack: Backpack;
	HopperBin: HopperBin;
	Tool: Tool;
	Flag: Flag;
	Beam: Beam;
	BindableEvent: BindableEvent;
	BindableFunction: BindableFunction;
	BodyAngularVelocity: BodyAngularVelocity;
	BodyForce: BodyForce;
	BodyGyro: BodyGyro;
	BodyPosition: BodyPosition;
	BodyThrust: BodyThrust;
	BodyVelocity: BodyVelocity;
	RocketPropulsion: RocketPropulsion;
	Camera: Camera;
	BodyColors: BodyColors;
	CharacterMesh: CharacterMesh;
	Pants: Pants;
	Shirt: Shirt;
	ShirtGraphic: ShirtGraphic;
	Skin: Skin;
	ClickDetector: ClickDetector;
	Configuration: Configuration;
	AlignOrientation: AlignOrientation;
	AlignPosition: AlignPosition;
	AngularVelocity: AngularVelocity;
	BallSocketConstraint: BallSocketConstraint;
	HingeConstraint: HingeConstraint;
	LineForce: LineForce;
	RodConstraint: RodConstraint;
	RopeConstraint: RopeConstraint;
	CylindricalConstraint: CylindricalConstraint;
	PrismaticConstraint: PrismaticConstraint;
	SpringConstraint: SpringConstraint;
	Torque: Torque;
	VectorForce: VectorForce;
	HumanoidController: HumanoidController;
	SkateboardController: SkateboardController;
	VehicleController: VehicleController;
	CustomEvent: CustomEvent;
	CustomEventReceiver: CustomEventReceiver;
	BlockMesh: BlockMesh;
	CylinderMesh: CylinderMesh;
	FileMesh: FileMesh;
	SpecialMesh: SpecialMesh;
	DebuggerWatch: DebuggerWatch;
	Dialog: Dialog;
	DialogChoice: DialogChoice;
	Dragger: Dragger;
	Explosion: Explosion;
	Decal: Decal;
	Texture: Texture;
	Hole: Hole;
	MotorFeature: MotorFeature;
	Fire: Fire;
	Folder: Folder;
	ForceField: ForceField;
	FunctionalTest: FunctionalTest;
	Frame: Frame;
	ImageButton: ImageButton;
	TextButton: TextButton;
	ImageLabel: ImageLabel;
	TextLabel: TextLabel;
	ScrollingFrame: ScrollingFrame;
	TextBox: TextBox;
	ViewportFrame: ViewportFrame;
	BillboardGui: BillboardGui;
	ScreenGui: ScreenGui;
	GuiMain: GuiMain;
	SurfaceGui: SurfaceGui;
	FloorWire: FloorWire;
	BoxHandleAdornment: BoxHandleAdornment;
	ConeHandleAdornment: ConeHandleAdornment;
	CylinderHandleAdornment: CylinderHandleAdornment;
	ImageHandleAdornment: ImageHandleAdornment;
	LineHandleAdornment: LineHandleAdornment;
	SphereHandleAdornment: SphereHandleAdornment;
	SelectionBox: SelectionBox;
	SelectionSphere: SelectionSphere;
	ArcHandles: ArcHandles;
	Handles: Handles;
	SurfaceSelection: SurfaceSelection;
	SelectionPartLasso: SelectionPartLasso;
	SelectionPointLasso: SelectionPointLasso;
	Humanoid: Humanoid;
	HumanoidDescription: HumanoidDescription;
	RotateP: RotateP;
	RotateV: RotateV;
	Glue: Glue;
	ManualGlue: ManualGlue;
	ManualWeld: ManualWeld;
	Motor: Motor;
	Motor6D: Motor6D;
	Rotate: Rotate;
	Snap: Snap;
	VelocityMotor: VelocityMotor;
	Weld: Weld;
	Keyframe: Keyframe;
	KeyframeMarker: KeyframeMarker;
	KeyframeSequence: KeyframeSequence;
	PointLight: PointLight;
	SpotLight: SpotLight;
	SurfaceLight: SurfaceLight;
	LocalizationTable: LocalizationTable;
	Script: Script;
	LocalScript: LocalScript;
	ModuleScript: ModuleScript;
	Message: Message;
	Hint: Hint;
	NoCollisionConstraint: NoCollisionConstraint;
	CornerWedgePart: CornerWedgePart;
	Part: Part;
	FlagStand: FlagStand;
	Seat: Seat;
	SkateboardPlatform: SkateboardPlatform;
	SpawnLocation: SpawnLocation;
	WedgePart: WedgePart;
	MeshPart: MeshPart;
	PartOperation: PartOperation;
	NegateOperation: NegateOperation;
	UnionOperation: UnionOperation;
	TrussPart: TrussPart;
	VehicleSeat: VehicleSeat;
	Model: Model;
	PartOperationAsset: PartOperationAsset;
	ParticleEmitter: ParticleEmitter;
	PluginAction: PluginAction;
	Pose: Pose;
	BloomEffect: BloomEffect;
	BlurEffect: BlurEffect;
	ColorCorrectionEffect: ColorCorrectionEffect;
	SunRaysEffect: SunRaysEffect;
	ReflectionMetadata: ReflectionMetadata;
	ReflectionMetadataCallbacks: ReflectionMetadataCallbacks;
	ReflectionMetadataClasses: ReflectionMetadataClasses;
	ReflectionMetadataEnums: ReflectionMetadataEnums;
	ReflectionMetadataEvents: ReflectionMetadataEvents;
	ReflectionMetadataFunctions: ReflectionMetadataFunctions;
	ReflectionMetadataClass: ReflectionMetadataClass;
	ReflectionMetadataEnum: ReflectionMetadataEnum;
	ReflectionMetadataEnumItem: ReflectionMetadataEnumItem;
	ReflectionMetadataMember: ReflectionMetadataMember;
	ReflectionMetadataProperties: ReflectionMetadataProperties;
	ReflectionMetadataYieldFunctions: ReflectionMetadataYieldFunctions;
	RemoteEvent: RemoteEvent;
	RemoteFunction: RemoteFunction;
	RenderingTest: RenderingTest;
	Sky: Sky;
	Smoke: Smoke;
	Sound: Sound;
	ChorusSoundEffect: ChorusSoundEffect;
	CompressorSoundEffect: CompressorSoundEffect;
	DistortionSoundEffect: DistortionSoundEffect;
	EchoSoundEffect: EchoSoundEffect;
	EqualizerSoundEffect: EqualizerSoundEffect;
	FlangeSoundEffect: FlangeSoundEffect;
	PitchShiftSoundEffect: PitchShiftSoundEffect;
	ReverbSoundEffect: ReverbSoundEffect;
	TremoloSoundEffect: TremoloSoundEffect;
	SoundGroup: SoundGroup;
	Sparkles: Sparkles;
	StarterGear: StarterGear;
	Team: Team;
	TerrainRegion: TerrainRegion;
	Trail: Trail;
	Tween: Tween;
	UIAspectRatioConstraint: UIAspectRatioConstraint;
	UISizeConstraint: UISizeConstraint;
	UITextSizeConstraint: UITextSizeConstraint;
	UIGridLayout: UIGridLayout;
	UIInlineLayout: UIInlineLayout;
	UIListLayout: UIListLayout;
	UIPageLayout: UIPageLayout;
	UITableLayout: UITableLayout;
	UIPadding: UIPadding;
	UIScale: UIScale;
	BinaryStringValue: BinaryStringValue;
	BoolValue: BoolValue;
	BrickColorValue: BrickColorValue;
	CFrameValue: CFrameValue;
	Color3Value: Color3Value;
	DoubleConstrainedValue: DoubleConstrainedValue;
	IntConstrainedValue: IntConstrainedValue;
	IntValue: IntValue;
	NumberValue: NumberValue;
	ObjectValue: ObjectValue;
	RayValue: RayValue;
	StringValue: StringValue;
	Vector3Value: Vector3Value;
	WeldConstraint: WeldConstraint;
}

interface Instances extends Services, CreatableInstances {
	Instance: Instance;
	AnimationTrack: AnimationTrack;
	BackpackItem: BackpackItem;
	BasePlayerGui: BasePlayerGui;
	PlayerGui: PlayerGui;
	BodyMover: BodyMover;
	CharacterAppearance: CharacterAppearance;
	Clothing: Clothing;
	Constraint: Constraint;
	SlidingBallConstraint: SlidingBallConstraint;
	Controller: Controller;
	DataModelMesh: DataModelMesh;
	BevelMesh: BevelMesh;
	DebugSettings: DebugSettings;
	DebuggerBreakpoint: DebuggerBreakpoint;
	DebuggerManager: DebuggerManager;
	FaceInstance: FaceInstance;
	Feature: Feature;
	File: File;
	GameSettings: GameSettings;
	GlobalDataStore: GlobalDataStore;
	OrderedDataStore: OrderedDataStore;
	GuiBase: GuiBase;
	GuiBase2d: GuiBase2d;
	GuiObject: GuiObject;
	GuiButton: GuiButton;
	GuiLabel: GuiLabel;
	LayerCollector: LayerCollector;
	PluginGui: PluginGui;
	DockWidgetPluginGui: DockWidgetPluginGui;
	QWidgetPluginGui: QWidgetPluginGui;
	GuiBase3d: GuiBase3d;
	PVAdornment: PVAdornment;
	HandleAdornment: HandleAdornment;
	ParabolaAdornment: ParabolaAdornment;
	PartAdornment: PartAdornment;
	HandlesBase: HandlesBase;
	SelectionLasso: SelectionLasso;
	HttpRequest: HttpRequest;
	InputObject: InputObject;
	JointInstance: JointInstance;
	DynamicRotate: DynamicRotate;
	ManualSurfaceJointInstance: ManualSurfaceJointInstance;
	Light: Light;
	LuaSettings: LuaSettings;
	LuaSourceContainer: LuaSourceContainer;
	BaseScript: BaseScript;
	CoreScript: CoreScript;
	Mouse: Mouse;
	PlayerMouse: PlayerMouse;
	PluginMouse: PluginMouse;
	NetworkMarker: NetworkMarker;
	NetworkPeer: NetworkPeer;
	NetworkReplicator: NetworkReplicator;
	ClientReplicator: ClientReplicator;
	ServerReplicator: ServerReplicator;
	PVInstance: PVInstance;
	BasePart: BasePart;
	FormFactorPart: FormFactorPart;
	Platform: Platform;
	Terrain: Terrain;
	TriangleMeshPart: TriangleMeshPart;
	Status: Status;
	PackageLink: PackageLink;
	Pages: Pages;
	DataStorePages: DataStorePages;
	FriendPages: FriendPages;
	InventoryPages: InventoryPages;
	EmotesPages: EmotesPages;
	StandardPages: StandardPages;
	Path: Path;
	PhysicsSettings: PhysicsSettings;
	Player: Player;
	PlayerScripts: PlayerScripts;
	Plugin: Plugin;
	PluginDragEvent: PluginDragEvent;
	PluginManager: PluginManager;
	PluginMenu: PluginMenu;
	PluginToolbar: PluginToolbar;
	PluginToolbarButton: PluginToolbarButton;
	PostEffect: PostEffect;
	ReflectionMetadataItem: ReflectionMetadataItem;
	ScriptDebugger: ScriptDebugger;
	ServiceProvider: ServiceProvider;
	DataModel: DataModel;
	GenericSettings: GenericSettings;
	AnalysticsSettings: AnalysticsSettings;
	GlobalSettings: GlobalSettings;
	UserSettings: UserSettings;
	SoundEffect: SoundEffect;
	StarterPlayerScripts: StarterPlayerScripts;
	StarterCharacterScripts: StarterCharacterScripts;
	StatsItem: StatsItem;
	RunningAverageItemDouble: RunningAverageItemDouble;
	RunningAverageItemInt: RunningAverageItemInt;
	RunningAverageTimeIntervalItem: RunningAverageTimeIntervalItem;
	TotalCountTimeIntervalItem: TotalCountTimeIntervalItem;
	StudioTheme: StudioTheme;
	TextFilterResult: TextFilterResult;
	TouchTransmitter: TouchTransmitter;
	Translator: Translator;
	TweenBase: TweenBase;
	UIBase: UIBase;
	UIComponent: UIComponent;
	UIConstraint: UIConstraint;
	UILayout: UILayout;
	UIGridStyleLayout: UIGridStyleLayout;
	ValueBase: ValueBase;
}

// GENERATED ROBLOX INSTANCE CLASSES

interface Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Instance" | "ABTestService" | "Accoutrement" | "AdService" | "AdvancedDragger" | "Animation" | "AnimationController" | "AnimationTrack" | "Animator" | "AssetService" | "Attachment" | "Backpack" | "BackpackItem" | "BadgeService" | "BasePlayerGui" | "Beam" | "BindableEvent" | "BindableFunction" | "BodyMover" | "BrowserService" | "CacheableContentProvider" | "Camera" | "ChangeHistoryService" | "CharacterAppearance" | "Chat" | "ClickDetector" | "ClusterPacketCache" | "CollectionService" | "Configuration" | "Constraint" | "ContentProvider" | "ContextActionService" | "Controller" | "ControllerService" | "CookiesService" | "CorePackages" | "CoreScriptSyncService" | "CustomEvent" | "CustomEventReceiver" | "DataModelMesh" | "DataStoreService" | "Debris" | "DebugSettings" | "DebuggerBreakpoint" | "DebuggerManager" | "DebuggerWatch" | "Dialog" | "DialogChoice" | "Dragger" | "Explosion" | "FaceInstance" | "Feature" | "File" | "Fire" | "FlagStandService" | "FlyweightService" | "Folder" | "ForceField" | "FriendService" | "FunctionalTest" | "GamePassService" | "GameSettings" | "GamepadService" | "Geometry" | "GlobalDataStore" | "GoogleAnalyticsConfiguration" | "GroupService" | "GuiBase" | "GuiService" | "GuidRegistryService" | "HapticService" | "Hopper" | "HttpRbxApiService" | "HttpRequest" | "HttpService" | "Humanoid" | "HumanoidDescription" | "InputObject" | "InsertService" | "JointInstance" | "JointsService" | "KeyboardService" | "Keyframe" | "KeyframeMarker" | "KeyframeSequence" | "KeyframeSequenceProvider" | "Light" | "Lighting" | "LocalStorageService" | "LocalizationService" | "LocalizationTable" | "LogService" | "LoginService" | "LuaSettings" | "LuaSourceContainer" | "LuaWebService" | "MarketplaceService" | "Message" | "MessagingService" | "Mouse" | "MouseService" | "NetworkMarker" | "NetworkPeer" | "NetworkReplicator" | "NetworkSettings" | "NoCollisionConstraint" | "NotificationService" | "PVInstance" | "PackageLink" | "PackageService" | "Pages" | "PartOperationAsset" | "ParticleEmitter" | "Path" | "PathfindingService" | "PhysicsPacketCache" | "PhysicsService" | "PhysicsSettings" | "Player" | "PlayerScripts" | "Players" | "Plugin" | "PluginAction" | "PluginDragEvent" | "PluginGuiService" | "PluginManager" | "PluginMenu" | "PluginToolbar" | "PluginToolbarButton" | "PointsService" | "Pose" | "PostEffect" | "RbxAnalyticsService" | "ReflectionMetadata" | "ReflectionMetadataCallbacks" | "ReflectionMetadataClasses" | "ReflectionMetadataEnums" | "ReflectionMetadataEvents" | "ReflectionMetadataFunctions" | "ReflectionMetadataItem" | "ReflectionMetadataProperties" | "ReflectionMetadataYieldFunctions" | "RemoteEvent" | "RemoteFunction" | "RenderSettings" | "RenderingTest" | "ReplicatedFirst" | "ReplicatedStorage" | "RobloxPluginGuiService" | "RobloxReplicatedStorage" | "RunService" | "RuntimeScriptService" | "ScriptContext" | "ScriptDebugger" | "ScriptService" | "Selection" | "ServerScriptService" | "ServerStorage" | "ServiceProvider" | "Sky" | "Smoke" | "SocialService" | "Sound" | "SoundEffect" | "SoundGroup" | "SoundService" | "Sparkles" | "SpawnerService" | "StarterGear" | "StarterPack" | "StarterPlayer" | "StarterPlayerScripts" | "Stats" | "StatsItem" | "StopWatchReporter" | "Studio" | "StudioData" | "StudioService" | "StudioTheme" | "TaskScheduler" | "Team" | "Teams" | "TeleportService" | "TerrainRegion" | "TestService" | "TextFilterResult" | "TextService" | "ThirdPartyUserService" | "TimerService" | "TouchInputService" | "TouchTransmitter" | "Trail" | "Translator" | "TweenBase" | "TweenService" | "UIBase" | "UserGameSettings" | "UserInputService" | "VRService" | "ValueBase" | "VirtualInputManager" | "VirtualUser" | "Visit" | "WeldConstraint" | "Accessory" | "Hat" | "HopperBin" | "Tool" | "Flag" | "CoreGui" | "PlayerGui" | "StarterGui" | "BodyAngularVelocity" | "BodyForce" | "BodyGyro" | "BodyPosition" | "BodyThrust" | "BodyVelocity" | "RocketPropulsion" | "MeshContentProvider" | "SolidModelContentProvider" | "BodyColors" | "CharacterMesh" | "Clothing" | "ShirtGraphic" | "Skin" | "Pants" | "Shirt" | "AlignOrientation" | "AlignPosition" | "AngularVelocity" | "BallSocketConstraint" | "HingeConstraint" | "LineForce" | "RodConstraint" | "RopeConstraint" | "SlidingBallConstraint" | "SpringConstraint" | "Torque" | "VectorForce" | "CylindricalConstraint" | "PrismaticConstraint" | "HumanoidController" | "SkateboardController" | "VehicleController" | "BevelMesh" | "FileMesh" | "BlockMesh" | "CylinderMesh" | "SpecialMesh" | "Decal" | "Texture" | "Hole" | "MotorFeature" | "CSGDictionaryService" | "NonReplicatedCSGDictionaryService" | "OrderedDataStore" | "GuiBase2d" | "GuiBase3d" | "GuiObject" | "LayerCollector" | "Frame" | "GuiButton" | "GuiLabel" | "ScrollingFrame" | "TextBox" | "ViewportFrame" | "ImageButton" | "TextButton" | "ImageLabel" | "TextLabel" | "BillboardGui" | "PluginGui" | "ScreenGui" | "SurfaceGui" | "DockWidgetPluginGui" | "QWidgetPluginGui" | "GuiMain" | "FloorWire" | "PVAdornment" | "PartAdornment" | "SelectionLasso" | "HandleAdornment" | "ParabolaAdornment" | "SelectionBox" | "SelectionSphere" | "BoxHandleAdornment" | "ConeHandleAdornment" | "CylinderHandleAdornment" | "ImageHandleAdornment" | "LineHandleAdornment" | "SphereHandleAdornment" | "HandlesBase" | "SurfaceSelection" | "ArcHandles" | "Handles" | "SelectionPartLasso" | "SelectionPointLasso" | "DynamicRotate" | "Glue" | "ManualSurfaceJointInstance" | "Motor" | "Rotate" | "Snap" | "VelocityMotor" | "Weld" | "RotateP" | "RotateV" | "ManualGlue" | "ManualWeld" | "Motor6D" | "PointLight" | "SpotLight" | "SurfaceLight" | "AppStorageService" | "UserStorageService" | "BaseScript" | "ModuleScript" | "CoreScript" | "Script" | "LocalScript" | "Hint" | "PlayerMouse" | "PluginMouse" | "NetworkClient" | "NetworkServer" | "ClientReplicator" | "ServerReplicator" | "BasePart" | "Model" | "CornerWedgePart" | "FormFactorPart" | "Terrain" | "TriangleMeshPart" | "TrussPart" | "VehicleSeat" | "Part" | "WedgePart" | "FlagStand" | "Platform" | "Seat" | "SkateboardPlatform" | "SpawnLocation" | "MeshPart" | "PartOperation" | "NegateOperation" | "UnionOperation" | "Status" | "Workspace" | "DataStorePages" | "FriendPages" | "InventoryPages" | "StandardPages" | "EmotesPages" | "BloomEffect" | "BlurEffect" | "ColorCorrectionEffect" | "SunRaysEffect" | "ReflectionMetadataClass" | "ReflectionMetadataEnum" | "ReflectionMetadataEnumItem" | "ReflectionMetadataMember" | "DataModel" | "GenericSettings" | "AnalysticsSettings" | "GlobalSettings" | "UserSettings" | "ChorusSoundEffect" | "CompressorSoundEffect" | "DistortionSoundEffect" | "EchoSoundEffect" | "EqualizerSoundEffect" | "FlangeSoundEffect" | "PitchShiftSoundEffect" | "ReverbSoundEffect" | "TremoloSoundEffect" | "StarterCharacterScripts" | "RunningAverageItemDouble" | "RunningAverageItemInt" | "RunningAverageTimeIntervalItem" | "TotalCountTimeIntervalItem" | "Tween" | "UIComponent" | "UIConstraint" | "UILayout" | "UIPadding" | "UIScale" | "UIAspectRatioConstraint" | "UISizeConstraint" | "UITextSizeConstraint" | "UIGridStyleLayout" | "UIGridLayout" | "UIInlineLayout" | "UIListLayout" | "UIPageLayout" | "UITableLayout" | "BinaryStringValue" | "BoolValue" | "BrickColorValue" | "CFrameValue" | "Color3Value" | "DoubleConstrainedValue" | "IntConstrainedValue" | "IntValue" | "NumberValue" | "ObjectValue" | "RayValue" | "StringValue" | "Vector3Value";
	/** Determines whether or not an Instance can be saved when the game closes/attempts to save the game. Note: this only applies to games that use Data Persistence, or SavePlaceAsync. */
	Archivable: boolean;
	Name: string;
	/** The Instance that is directly above this Instance in the tree. */
	Parent?: Instance;
	/** Removes all children (but not this object) from the workspace. */
	ClearAllChildren(): void;
	/** Returns a copy of this Object and all its children. The copy's Parent is nil */
	Clone(): this;
	/** Removes object and all of its children from the workspace. Disconnects object and all children from open connections. Object and children may not be usable after calling Destroy. */
	Destroy(): void;
	/** Returns the first ancestor of this Instance that matches the first argument 'name'.  The function will return nil if no Instance is found. */
	FindFirstAncestor<T extends Instance = Instance>(name: string): T | undefined;
	/** Returns the first ancestor of this Instance with a ClassName equal to 'className'.  The function will return nil if no Instance is found. */
	FindFirstAncestorOfClass<T extends Instance["ClassName"]>(className: T): StrictInstances[T] | undefined;
	FindFirstAncestorOfClass(className: string): Instance | undefined;
	/** Returns the first ancestor of this Instance that :IsA(className).  The function will return nil if no Instance is found. */
	FindFirstAncestorWhichIsA<T extends keyof Instances>(className: T): Instances[T] | undefined;
	FindFirstAncestorWhichIsA(className: string): Instance | undefined;
	/** Returns the first child of this Instance that matches the first argument 'name'.  The second argument 'recursive' is an optional boolean (defaults to false) that will force the call to traverse down thru all of this Instance's descendants until it finds an object with a name that matches the 'name' argument.  The function will return nil if no Instance is found. */
	FindFirstChild<T extends Instance = Instance>(name: string, recursive?: boolean): T | undefined;
	/** Returns the first child of this Instance that with a ClassName equal to 'className'.  The function will return nil if no Instance is found. */
	FindFirstChildOfClass<T extends Instance["ClassName"]>(className: T): StrictInstances[T] | undefined;
	FindFirstChildOfClass(className: string): Instance | undefined;
	/** Returns the first child of this Instance that :IsA(className).  The second argument 'recursive' is an optional boolean (defaults to false) that will force the call to traverse down thru all of this Instance's descendants until it finds an object with a name that matches the 'className' argument.  The function will return nil if no Instance is found. */
	FindFirstChildWhichIsA<T extends keyof Instances>(className: T, recursive?: boolean): Instances[T] | undefined;
	FindFirstChildWhichIsA(className: string, recursive?: boolean): Instance | undefined;
	/** Returns a read-only table of this Object's children */
	GetChildren<T extends Instance = Instance>(): Array<T>;
	/** Returns an array containing all of the descendants of the instance. Returns in preorder traversal, or in other words, where the parents come before their children, depth first. */
	GetDescendants(): Array<Instance>;
	/** Returns a string that shows the path from the root node (DataModel) to this Instance.  This string does not include the root node (DataModel). */
	GetFullName(): string;

	GetPropertyChangedSignal<T extends GetProperties<this>>(propertyName: T): RBXScriptSignal;
	GetPropertyChangedSignal(propertyName: string): RBXScriptSignal;
	/** Returns a boolean if this Instance is of type 'className' or a is a subclass of type 'className'.  If 'className' is not a valid class type in ROBLOX, this function will always return false.  [More info](http://wiki.roblox.com/index.php/IsA) */
	IsA<
		T extends {
			[K in keyof Instances]: Instances[K]["ClassName"] extends this["ClassName"]
				? this extends Instances[K]
					? never
					: K
				: never
		}[keyof Instances]
	>(
		className: T,
	): this is Instances[T];
	IsA(className: string): boolean;
	IsAncestorOf(descendant: Instance): boolean;
	IsDescendantOf(ancestor: Instance): boolean;

	WaitForChild<T extends Instance = Instance>(childName: string): T;
	WaitForChild<T extends Instance = Instance>(childName: string, timeOut: number): T | undefined;
	/** Fired when any of this object's ancestors change.  First argument 'child' is the object whose parent changed.  Second argument 'parent' is the first argument's new parent. */
	readonly AncestryChanged: RBXScriptSignal<(child: Instance, parent: Instance) => void>;
	readonly ChildAdded: RBXScriptSignal<(child: Instance) => void>;
	readonly ChildRemoved: RBXScriptSignal<(child: Instance) => void>;
	/** Fired after an Instance is parented to this object, or any of this object's descendants.  The 'descendant' argument is the Instance that is being added. */
	readonly DescendantAdded: RBXScriptSignal<(descendant: Instance) => void>;
	/** Fired after an Instance is unparented from this object, or any of this object's descendants.  The 'descendant' argument is the Instance that is being added. */
	readonly DescendantRemoving: RBXScriptSignal<(descendant: Instance) => void>;
}

interface ABTestService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ABTestService";
}

interface Accoutrement extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Accoutrement" | "Accessory" | "Hat";
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	AttachmentForward: Vector3;
	/** [NO DOCUMENTATION] */
	AttachmentPoint: CFrame;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	AttachmentPos: Vector3;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	AttachmentRight: Vector3;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	AttachmentUp: Vector3;
}

interface Accessory extends Accoutrement {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Accessory";
}

interface Hat extends Accoutrement {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Hat";
}

interface AdService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "AdService";
}

interface AdvancedDragger extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "AdvancedDragger";
}

interface Animation extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Animation";
	/** [NO DOCUMENTATION] */
	AnimationId: string;
}

interface AnimationController extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "AnimationController";

	GetPlayingAnimationTracks(): Array<AnimationTrack>;

	LoadAnimation(animation: Animation): AnimationTrack;

	readonly AnimationPlayed: RBXScriptSignal<(animationTrack: AnimationTrack) => void>;
}

interface AnimationTrack extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "AnimationTrack";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Animation?: Animation;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly IsPlaying: boolean;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Length: number;
	/** [NO DOCUMENTATION] */
	Looped: boolean;
	/** [NO DOCUMENTATION] */
	Priority: Enum.AnimationPriority;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Speed: number;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	TimePosition: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly WeightCurrent: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly WeightTarget: number;
	/** [NO DOCUMENTATION] */
	AdjustSpeed(speed?: number): void;
	/** [NO DOCUMENTATION] */
	AdjustWeight(weight?: number, fadeTime?: number): void;
	/** [NO DOCUMENTATION] */
	GetMarkerReachedSignal(name: string): RBXScriptSignal;
	/** [NO DOCUMENTATION] */
	GetTimeOfKeyframe(keyframeName: string): number;
	/** [NO DOCUMENTATION] */
	Play(fadeTime?: number, weight?: number, speed?: number): void;
	/** [NO DOCUMENTATION] */
	Stop(fadeTime?: number): void;
	/** [NO DOCUMENTATION] */
	readonly DidLoop: RBXScriptSignal<() => void>;
	/** [NO DOCUMENTATION] */
	readonly KeyframeReached: RBXScriptSignal<(keyframeName: string) => void>;
	/** [NO DOCUMENTATION] */
	readonly Stopped: RBXScriptSignal<() => void>;
}

interface Animator extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Animator";

	LoadAnimation(animation: Animation): AnimationTrack;
}

/** @rbxts server */
interface AssetService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "AssetService";
	CreatePlaceAsync(placeName: string, templatePlaceID: number, description?: string): number;

	CreatePlaceInPlayerInventoryAsync(
		player: Player,
		placeName: string,
		templatePlaceID: number,
		description?: string,
	): number;

	GetAssetIdsForPackage(packageAssetId: number): Array<number>;

	GetBundleDetailsAsync(bundleId: number): BundleInfo;

	GetGamePlacesAsync(): StandardPages;
	SavePlaceAsync(): void;
}

interface Attachment extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Attachment";
	/** Primary axis. Corresponds to the LookVector, or the first column in the part-local Attachment CFrame rotation matrix */
	Axis: Vector3;
	CFrame: CFrame;
	/** Euler angles applied in YXZ order */
	Orientation: Vector3;
	Position: Vector3;
	/** Secondary axis. Corresponds to the UpVector, or the second column in the part-local Attachment CFrame rotation matrix */
	SecondaryAxis: Vector3;
	Visible: boolean;
	/** Primary axis in world space. Corresponds to the LookVector, or the first column in the world space Attachment CFrame rotation matrix. */
	WorldAxis: Vector3;

	WorldCFrame: CFrame;
	/** Euler angles applied in YXZ order */
	WorldOrientation: Vector3;
	WorldPosition: Vector3;
	WorldSecondaryAxis: Vector3;
}

interface Backpack extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Backpack";
}

interface BackpackItem extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BackpackItem" | "HopperBin" | "Tool" | "Flag";
	/** [NO DOCUMENTATION] */
	TextureId: string;
}

interface HopperBin extends BackpackItem {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "HopperBin";
	/** [NO DOCUMENTATION] */
	Active: boolean;
	/** [NO DOCUMENTATION] */
	BinType: Enum.BinType;
	/** [NO DOCUMENTATION] */
	readonly Deselected: RBXScriptSignal<() => void>;
	/** [NO DOCUMENTATION] */
	readonly Selected: RBXScriptSignal<(mouse: Instance) => void>;
}

interface Tool extends BackpackItem {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Tool" | "Flag";
	CanBeDropped: boolean;
	Enabled: boolean;
	Grip: CFrame;
	GripForward: Vector3;
	GripPos: Vector3;
	GripRight: Vector3;
	GripUp: Vector3;
	ManualActivationOnly: boolean;
	RequiresHandle: boolean;
	ToolTip: string;
	Activate(): void;
	Deactivate(): void;
	readonly Activated: RBXScriptSignal<() => void>;
	readonly Deactivated: RBXScriptSignal<() => void>;

	readonly Equipped: RBXScriptSignal<(mouse: Mouse) => void>;
	readonly Unequipped: RBXScriptSignal<() => void>;
}

interface Flag extends Tool {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Flag";
	/** The Team this flag is for. Corresponds with the TeamColors in the Teams service. */
	TeamColor: BrickColor;
}

interface BadgeService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BadgeService";
	/** @rbxts server */
	AwardBadge(userId: number, badgeId: number): boolean;
	/** @rbxts server */
	GetBadgeInfoAsync(badgeId: number): BadgeInfo;
	/** @rbxts server */
	UserHasBadgeAsync(userId: number, badgeId: number): boolean;
}

interface BasePlayerGui extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BasePlayerGui" | "CoreGui" | "PlayerGui" | "StarterGui";
	/** [NO DOCUMENTATION] */
	GetGuiObjectsAtPosition(x: number, y: number): Array<Instance>;
}

interface CoreGui extends BasePlayerGui {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CoreGui";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Version: number;
}

interface PlayerGui extends BasePlayerGui {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PlayerGui";
	readonly CurrentScreenOrientation: Enum.ScreenOrientation;
	ScreenOrientation: Enum.ScreenOrientation;
	/** Overrides the default selection adornment (used for gamepads). For best results, this should point to a GuiObject. */
	SelectionImageObject?: GuiObject;
	GetTopbarTransparency(): number;
	SetTopbarTransparency(transparency: number): void;
	readonly TopbarTransparencyChangedSignal: RBXScriptSignal<(transparency: number) => void>;
}

interface StarterGui extends BasePlayerGui {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "StarterGui";
	ScreenOrientation: Enum.ScreenOrientation;
	ShowDevelopmentGui: boolean;
	/** Returns a boolean describing whether a CoreGuiType is currently being rendered. */
	GetCoreGuiEnabled(coreGuiType: CastsToEnum<Enum.CoreGuiType>): boolean;

	SetCore(parameterName: "ChatActive", active: boolean): void;
	SetCore(parameterName: "PointsNotificationsActive", active: boolean): void;
	SetCore(parameterName: "BadgeNotificationsActive", active: boolean): void;
	SetCore(parameterName: "ResetButtonCallback", enabled: boolean): void;
	SetCore(parameterName: "ResetButtonCallback", callback: BindableEvent): void;
	SetCore(parameterName: "ChatMakeSystemMessage", configTable: MakeSystemMessageConfig): void;
	SetCore(parameterName: "ChatWindowSize", windowSize: UDim2): void;
	SetCore(parameterName: "ChatWindowPosition", windowPosition: UDim2): void;
	SetCore(parameterName: "ChatBarDisabled", disabled: boolean): void;
	SetCore(parameterName: "SendNotification", configTable: boolean): void;
	SetCore(parameterName: "TopbarEnabled", enabled: boolean): void;
	SetCore(parameterName: "DeveloperConsoleVisible", visibility: boolean): void;
	SetCore(parameterName: "PromptSendFriendRequest", player: Player): void;
	SetCore(parameterName: "PromptUnfriend", player: Player): void;
	SetCore(parameterName: "PromptBlockPlayer", player: Player): void;
	SetCore(parameterName: "PromptUnblockPlayer", player: Player): void;
	SetCore(parameterName: "AvatarContextMenuEnabled", enabled: boolean): void;
	SetCore(parameterName: "AddAvatarContextMenuOption", option: Enum.AvatarContextMenuOption): void;
	SetCore(parameterName: "AddAvatarContextMenuOption", option: [string, BindableFunction]): void;
	SetCore(parameterName: "RemoveAvatarContextMenuOption", option: Enum.AvatarContextMenuOption): void;
	SetCore(parameterName: "RemoveAvatarContextMenuOption", option: [string, BindableFunction]): void;
	SetCore(
		parameterName: "CoreGuiChatConnections",
		connections: { [name: string]: BindableEvent | BindableFunction },
	): void;
	/** Will stop/begin certain core gui elements being rendered. See CoreGuiType for core guis that can be modified. */
	SetCoreGuiEnabled(coreGuiType: CastsToEnum<Enum.CoreGuiType>, enabled: boolean): void;

	GetCore(parameterName: "AvatarContextMenuEnabled"): boolean;
	GetCore(parameterName: "PointsNotificationsActive"): boolean;
	GetCore(parameterName: "BadgesNotificationsActive"): boolean;
	GetCore(parameterName: "ChatActive"): boolean;
	GetCore(parameterName: "ChatWindowSize"): UDim2;
	GetCore(parameterName: "ChatWindowPosition"): UDim2;
	GetCore(parameterName: "ChatBarDisabled"): boolean;
	GetCore(parameterName: "GetBlockedUserIds"): Array<number>;
	GetCore(parameterName: "PlayerBlockedEvent"): BindableEvent;
	GetCore(parameterName: "PlayerUnblockedEvent"): BindableEvent;
	GetCore(parameterName: "PlayerMutedEvent"): BindableEvent;
	GetCore(parameterName: "PlayerUnmutedEvent"): BindableEvent;
	GetCore(parameterName: "PlayerFriendedEvent"): BindableEvent;
	GetCore(parameterName: "PlayerUnfriendedEvent"): BindableEvent;
	GetCore(parameterName: "DeveloperConsoleVisible"): boolean;
	GetCore(parameterName: "VRRotationIntensity"): "Low" | "High" | "Smooth";
}

interface Beam extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Beam";
	/** [NO DOCUMENTATION] */
	Attachment0?: Attachment;
	/** [NO DOCUMENTATION] */
	Attachment1?: Attachment;
	/** [NO DOCUMENTATION] */
	Color: ColorSequence;
	/** [NO DOCUMENTATION] */
	CurveSize0: number;
	/** [NO DOCUMENTATION] */
	CurveSize1: number;
	/** [NO DOCUMENTATION] */
	Enabled: boolean;
	/** [NO DOCUMENTATION] */
	FaceCamera: boolean;
	/** [NO DOCUMENTATION] */
	LightEmission: number;
	/** [NO DOCUMENTATION] */
	LightInfluence: number;
	/** [NO DOCUMENTATION] */
	Segments: number;
	/** [NO DOCUMENTATION] */
	Texture: string;
	/** [NO DOCUMENTATION] */
	TextureLength: number;
	/** [NO DOCUMENTATION] */
	TextureMode: Enum.TextureMode;
	/** [NO DOCUMENTATION] */
	TextureSpeed: number;
	/** [NO DOCUMENTATION] */
	Transparency: NumberSequence;
	/** [NO DOCUMENTATION] */
	Width0: number;
	/** [NO DOCUMENTATION] */
	Width1: number;
	/** [NO DOCUMENTATION] */
	ZOffset: number;
	/** [NO DOCUMENTATION] */
	SetTextureOffset(offset?: number): void;
}

interface BindableEvent extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BindableEvent";
	/** Used to make the custom event fire (see Event for more info). Arguments can be variable length. */
	Fire(...arguments: Array<unknown>): void;
	/** This event fires when the Fire() method is used.  Receives the variable length arguments from Fire(). */
	readonly Event: RBXScriptSignal<(...arguments: Array<unknown>) => void, true>;
}

interface BindableFunction extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BindableFunction";
	/** Causes the function assigned to OnInvoke to be called. Arguments passed to this function get passed to OnInvoke function. */
	Invoke(...arguments: Array<unknown>): Array<unknown>;
	/** Should be defined as a function. This function is called when Invoke() is called. Number of arguments is variable. */
	OnInvoke: (...arguments: Array<unknown>) => any;
}

interface BodyMover extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BodyMover" | "BodyAngularVelocity" | "BodyForce" | "BodyGyro" | "BodyPosition" | "BodyThrust" | "BodyVelocity" | "RocketPropulsion";
}

interface BodyAngularVelocity extends BodyMover {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BodyAngularVelocity";
	/** [NO DOCUMENTATION] */
	AngularVelocity: Vector3;
	/** [NO DOCUMENTATION] */
	MaxTorque: Vector3;
	/** [NO DOCUMENTATION] */
	P: number;
}

interface BodyForce extends BodyMover {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BodyForce";
	/** [NO DOCUMENTATION] */
	Force: Vector3;
}

interface BodyGyro extends BodyMover {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BodyGyro";
	/** The cframe that this force is trying to orient its parent Part to.  Note: this force only uses the rotation of the cframe, not the position. */
	CFrame: CFrame;
	/** The dampening factor applied to this force */
	D: number;
	/** The maximum torque that will be exerted on the Part */
	MaxTorque: Vector3;
	/** The power continually applied to this force */
	P: number;
}

interface BodyPosition extends BodyMover {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BodyPosition";
	/** The dampening factor applied to this force */
	D: number;
	/** The maximum force that will be exerted on the Part */
	MaxForce: Vector3;
	/** The power factor continually applied to this force */
	P: number;
	/** The Vector3 that this force is trying to position its parent Part to. */
	Position: Vector3;
	/** [NO DOCUMENTATION] */
	GetLastForce(): Vector3;
	/** [NO DOCUMENTATION] */
	readonly ReachedTarget: RBXScriptSignal<() => void>;
}

interface BodyThrust extends BodyMover {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BodyThrust";
	/** The power continually applied to this force */
	Force: Vector3;
	/** The Vector3 location of where to apply the force to.  */
	Location: Vector3;
}

interface BodyVelocity extends BodyMover {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BodyVelocity";
	/** The maximum force that will be exerted on the Part in each axis */
	MaxForce: Vector3;
	/** The amount of power we add to the system.  The higher the power, the quicker the force will achieve its goal. */
	P: number;
	/** The velocity this system tries to achieve.  How quickly the system reaches this velocity (if ever) is defined by P. */
	Velocity: Vector3;
	/** [NO DOCUMENTATION] */
	GetLastForce(): Vector3;
	/** [NO DOCUMENTATION] */
	lastForce(): Vector3;
}

interface RocketPropulsion extends BodyMover {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RocketPropulsion";
	/** [NO DOCUMENTATION] */
	CartoonFactor: number;
	/** [NO DOCUMENTATION] */
	MaxSpeed: number;
	/** [NO DOCUMENTATION] */
	MaxThrust: number;
	/** [NO DOCUMENTATION] */
	MaxTorque: Vector3;
	/** [NO DOCUMENTATION] */
	Target?: BasePart;
	/** [NO DOCUMENTATION] */
	TargetOffset: Vector3;
	/** [NO DOCUMENTATION] */
	TargetRadius: number;
	/** [NO DOCUMENTATION] */
	ThrustD: number;
	/** [NO DOCUMENTATION] */
	ThrustP: number;
	/** [NO DOCUMENTATION] */
	TurnD: number;
	/** [NO DOCUMENTATION] */
	TurnP: number;
	/** [NO DOCUMENTATION] */
	Abort(): void;
	/** [NO DOCUMENTATION] */
	Fire(): void;
	/** [NO DOCUMENTATION] */
	readonly ReachedTarget: RBXScriptSignal<() => void>;
}

interface BrowserService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BrowserService";
}

interface CacheableContentProvider extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CacheableContentProvider" | "MeshContentProvider" | "SolidModelContentProvider";
}

interface MeshContentProvider extends CacheableContentProvider {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "MeshContentProvider";
}

interface SolidModelContentProvider extends CacheableContentProvider {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SolidModelContentProvider";
}

interface Camera extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Camera";
	/** The current position and rotation of the Camera.  For most CameraTypes, the rotation is set such that the CoordinateFrame lookVector is pointing at the Focus. */
	CFrame: CFrame;
	/** Where the Camera's focus is.  Any rotation of the camera will be about this subject. */
	CameraSubject: Humanoid | BasePart | undefined;
	/** Defines how the camera will behave. [More info](http://wiki.roblox.com/index.php/CameraType) */
	CameraType: Enum.CameraType;
	/** The current angle, or width, of what the camera can see.  Current acceptable values are from 20 degrees to 80. */
	FieldOfView: number;
	/** The current CoordinateFrame that the camera is looking at.  Note: it is not always guaranteed that the camera is always looking here. */
	Focus: CFrame;
	HeadLocked: boolean;
	HeadScale: number;
	/** The negative z-offset of the view frustum's near clipping plane. */
	readonly NearPlaneZ: number;
	/** Holds the x,y screen resolution of the viewport the camera is presenting (note: this can differ from the AbsoluteSize property of a full screen gui). */
	readonly ViewportSize: Vector2;
	GetLargestCutoffDistance(ignoreList: Array<Instance>): number;
	GetPanSpeed(): number;

	GetPartsObscuringTarget(castPoints: Array<Vector3>, ignoreList: Array<Instance>): Array<Instance>;
	GetRenderCFrame(): CFrame;
	/** Returns the camera's current roll. Roll is defined in radians, and is stored as the delta from the camera's y axis default normal vector. */
	GetRoll(): number;
	GetTiltSpeed(): number;
	Interpolate(endPos: CFrame, endFocus: CFrame, duration: number): void;
	PanUnits(units: number): void;
	/** Takes a 2D screen position and produces a Ray object to be used for 3D raycasting. Input is x,y screen coordinates, and a (optional, defaults to 0) z position which sets how far in the camera look vector to start the ray origin. */
	ScreenPointToRay(x: number, y: number, depth?: number): Ray;
	SetCameraPanMode(mode?: CastsToEnum<Enum.CameraPanMode>): void;
	/** Sets the camera's current roll. Roll is defined in radians, and is stored as the delta from the camera's y axis default normal vector. */
	SetRoll(rollAngle: number): void;
	TiltUnits(units: number): boolean;
	/** Same as ScreenPointToRay, except no GUI offsets are taken into account. Useful for things like casting a ray from the middle of the Camera.ViewportSize */
	ViewportPointToRay(x: number, y: number, depth?: number): Ray;
	/** Takes a 3D position in the world and projects it onto x,y coordinates of screen space. Returns two values, first is a Vector3 that has x,y position and z position which is distance from camera (negative if behind camera, positive if in front). Second return value is a boolean indicating if the first argument is an on-screen coordinate. */
	WorldToScreenPoint(worldPoint: Vector3): LuaTuple<[Vector3, boolean]>;
	/** Same as WorldToScreenPoint, except no GUI offsets are taken into account. */
	WorldToViewportPoint(worldPoint: Vector3): LuaTuple<[Vector3, boolean]>;
	readonly InterpolationFinished: RBXScriptSignal<() => void>;
}

interface ChangeHistoryService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ChangeHistoryService";
}

interface CharacterAppearance extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CharacterAppearance" | "BodyColors" | "CharacterMesh" | "Clothing" | "ShirtGraphic" | "Skin" | "Pants" | "Shirt";
}

interface BodyColors extends CharacterAppearance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BodyColors";
	/** [NO DOCUMENTATION] */
	HeadColor: BrickColor;
	/** [NO DOCUMENTATION] */
	HeadColor3: Color3;
	/** [NO DOCUMENTATION] */
	LeftArmColor: BrickColor;
	/** [NO DOCUMENTATION] */
	LeftArmColor3: Color3;
	/** [NO DOCUMENTATION] */
	LeftLegColor: BrickColor;
	/** [NO DOCUMENTATION] */
	LeftLegColor3: Color3;
	/** [NO DOCUMENTATION] */
	RightArmColor: BrickColor;
	/** [NO DOCUMENTATION] */
	RightArmColor3: Color3;
	/** [NO DOCUMENTATION] */
	RightLegColor: BrickColor;
	/** [NO DOCUMENTATION] */
	RightLegColor3: Color3;
	/** [NO DOCUMENTATION] */
	TorsoColor: BrickColor;
	/** [NO DOCUMENTATION] */
	TorsoColor3: Color3;
}

interface CharacterMesh extends CharacterAppearance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CharacterMesh";
	/** [NO DOCUMENTATION] */
	BaseTextureId: number;
	/** [NO DOCUMENTATION] */
	BodyPart: Enum.BodyPart;
	/** [NO DOCUMENTATION] */
	MeshId: number;
	/** [NO DOCUMENTATION] */
	OverlayTextureId: number;
}

interface Clothing extends CharacterAppearance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Clothing" | "Pants" | "Shirt";
	/** [NO DOCUMENTATION] */
	Color3: Color3;
}

interface Pants extends Clothing {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Pants";
	/** [NO DOCUMENTATION] */
	PantsTemplate: string;
}

interface Shirt extends Clothing {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Shirt";
	/** [NO DOCUMENTATION] */
	ShirtTemplate: string;
}

interface ShirtGraphic extends CharacterAppearance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ShirtGraphic";
	/** [NO DOCUMENTATION] */
	Color3: Color3;
	/** [NO DOCUMENTATION] */
	Graphic: string;
}

interface Skin extends CharacterAppearance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Skin";
	/** [NO DOCUMENTATION] */
	SkinColor: BrickColor;
}

interface Chat extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Chat";
	BubbleChatEnabled: boolean;
	readonly LoadDefaultChat: boolean;

	Chat(partOrCharacter: BasePart | Model, message: string, color?: CastsToEnum<Enum.ChatColor>): void;
	InvokeChatCallback(callbackType: CastsToEnum<Enum.ChatCallbackType>, callbackArguments: Array<any>): unknown;
	RegisterChatCallback(callbackType: CastsToEnum<Enum.ChatCallbackType>, callbackFunction: Function): void;
	CanUserChatAsync(userId: number): boolean;
	CanUsersChatAsync(userIdFrom: number, userIdTo: number): boolean;

	FilterStringAsync(stringToFilter: string, playerFrom: Player, playerTo: Player): string;

	FilterStringForBroadcast(stringToFilter: string, playerFrom: Player): string;

	readonly Chatted: RBXScriptSignal<(part: BasePart, message: string, color: Enum.ChatColor) => void>;
}

interface ClickDetector extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ClickDetector";
	CursorIcon: string;
	/** The maximum distance a Player's character can be from the ClickDetector's parent Part that will allow the Player's mouse to fire events on this object. */
	MaxActivationDistance: number;
	/** Fired when a player clicks on the parent Part of ClickDetector. The argument provided is always of type Player. */
	readonly MouseClick: RBXScriptSignal<(playerWhoClicked: Player) => void>;
	/** Fired when a player's mouse enters on the parent Part of ClickDetector. The argument provided is always of type Player. */
	readonly MouseHoverEnter: RBXScriptSignal<(playerWhoHovered: Player) => void>;
	/** Fired when a player's mouse leaves the parent Part of ClickDetector. The argument provided is always of type Player. */
	readonly MouseHoverLeave: RBXScriptSignal<(playerWhoHovered: Player) => void>;

	readonly RightMouseClick: RBXScriptSignal<(playerWhoClicked: Player) => void>;
}

interface ClusterPacketCache extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ClusterPacketCache";
}

interface CollectionService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CollectionService";
	/** Adds a tag to an instance. */
	AddTag(instance: Instance, tag: string): void;
	/** Returns a signal that fires when the given tag either has a new instance with that tag added to the data model or that tag is assigned to an instance within the data model. */
	GetInstanceAddedSignal(tag: string): RBXScriptSignal<(instance: Instance) => void>;
	/** Returns a signal that fires when the given tag either has an instance with that tag removed from the data model or that tag is removed from an instance within the data model. */
	GetInstanceRemovedSignal(tag: string): RBXScriptSignal<(instance: Instance) => void>;
	/** Returns an array of all of the instances in the data model which have the given tag. */
	GetTagged<T extends Instance = Instance>(tag: string): Array<T>;
	/** Returns a list of all the collections that an instance belongs to. */
	GetTags(instance: Instance): Array<string>;
	/** Returns whether the given instance has the given tag. */
	HasTag(instance: Instance, tag: string): boolean;
	/** Removes a tag to an instance. */
	RemoveTag(instance: Instance, tag: string): void;
}

interface Configuration extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Configuration";
}

interface Constraint extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Constraint" | "AlignOrientation" | "AlignPosition" | "AngularVelocity" | "BallSocketConstraint" | "HingeConstraint" | "LineForce" | "RodConstraint" | "RopeConstraint" | "SlidingBallConstraint" | "SpringConstraint" | "Torque" | "VectorForce" | "CylindricalConstraint" | "PrismaticConstraint";
	/** Read-only boolean, true if the Constraint is active in world.Read-only boolean, true if the Constraint is active in world. *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Active: boolean;
	/** [NO DOCUMENTATION] */
	Attachment0?: Attachment;
	/** [NO DOCUMENTATION] */
	Attachment1?: Attachment;
	/** The color of the in-game visual. */
	Color: BrickColor;
	/** Toggles whether or not this constraint is enabled. Disabled constraints will not render in game. */
	Enabled: boolean;
	/** Toggles the in-game visual associated with this constraint. */
	Visible: boolean;
}

interface AlignOrientation extends Constraint {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "AlignOrientation";
	/** [NO DOCUMENTATION] */
	AlignType: Enum.AlignType;
	/** [NO DOCUMENTATION] */
	MaxAngularVelocity: number;
	/** [NO DOCUMENTATION] */
	MaxTorque: number;
	/** [NO DOCUMENTATION] */
	PrimaryAxisOnly: boolean;
	/** [NO DOCUMENTATION] */
	ReactionTorqueEnabled: boolean;
	/** [NO DOCUMENTATION] */
	Responsiveness: number;
	/** [NO DOCUMENTATION] */
	RigidityEnabled: boolean;
}

interface AlignPosition extends Constraint {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "AlignPosition";
	/** [NO DOCUMENTATION] */
	ApplyAtCenterOfMass: boolean;
	/** [NO DOCUMENTATION] */
	MaxForce: number;
	/** [NO DOCUMENTATION] */
	MaxVelocity: number;
	/** [NO DOCUMENTATION] */
	ReactionForceEnabled: boolean;
	/** [NO DOCUMENTATION] */
	Responsiveness: number;
	/** [NO DOCUMENTATION] */
	RigidityEnabled: boolean;
}

interface AngularVelocity extends Constraint {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "AngularVelocity";
	/** [NO DOCUMENTATION] */
	AngularVelocity: Vector3;
	/** [NO DOCUMENTATION] */
	MaxTorque: number;
	/** [NO DOCUMENTATION] */
	RelativeTo: Enum.ActuatorRelativeTo;
}

interface BallSocketConstraint extends Constraint {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BallSocketConstraint";
	/** Enables the angular limit between the axis of Attachment0 and the axis of Attachment1. */
	LimitsEnabled: boolean;
	/** Radius of the in-game visual. Value in [0, inf). */
	Radius: number;
	/** Restitution of the limit, or how elastic it is. Value in [0, 1]. */
	Restitution: number;
	/** Enables the angular limits around the main axis of Attachment1. */
	TwistLimitsEnabled: boolean;
	/** Lower angular limit around the axis of Attachment1. Value in [-180, 180]. */
	TwistLowerAngle: number;
	/** Upper angular limit around the axis of Attachment1. Value in [-180, 180]. */
	TwistUpperAngle: number;
	/** Maximum angle between the two main axes. Value in [0, 180]. */
	UpperAngle: number;
}

interface HingeConstraint extends Constraint {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "HingeConstraint";
	/** Type of the rotational actuator: None, Motor, or Servo.  */
	ActuatorType: Enum.ActuatorType;
	/** Target angular speed. This value is unsigned as the servo will always move toward its target. Value in [0, inf). */
	AngularSpeed: number;
	/** The target angular velocity of the motor in radians per second around the rotation axis. Value in [0, inf). */
	AngularVelocity: number;
	/** Signed angle between the SecondaryAxis of Attchement0 and the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180].Signed angle between the SecondaryAxis of Attchement0 and the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180]. *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly CurrentAngle: number;
	/** Enables the angular limits on rotations around the main axis of Attachment0. */
	LimitsEnabled: boolean;
	/** Lower limit for the angle from the SecondaryAxis of Attachment0 to the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180]. */
	LowerAngle: number;
	/** The maximum angular acceleration of the motor in radians per second square. Value in [0, inf). */
	MotorMaxAcceleration: number;
	/** The maximum torque the motor can apply to achieve the target angular velocity. Value in [0, inf). */
	MotorMaxTorque: number;
	/** Radius of the in-game visual. Value in [0, inf). */
	Radius: number;
	/** [NO DOCUMENTATION] */
	Restitution: number;
	/** Maximum torque the servo motor can apply. Value in [0, inf). */
	ServoMaxTorque: number;
	/** Target angle for the SecondaryAxis of Attachment1 from the SecondaryAxis of Attachment0 around the rotation axis. Value in [-180, 180]. */
	TargetAngle: number;
	/** Upper limit for the angle from the SecondaryAxis of Attachment0 to the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180]. */
	UpperAngle: number;
}

interface LineForce extends Constraint {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "LineForce";
	/** [NO DOCUMENTATION] */
	ApplyAtCenterOfMass: boolean;
	/** [NO DOCUMENTATION] */
	InverseSquareLaw: boolean;
	/** [NO DOCUMENTATION] */
	Magnitude: number;
	/** [NO DOCUMENTATION] */
	MaxForce: number;
	/** [NO DOCUMENTATION] */
	ReactionForceEnabled: boolean;
}

interface RodConstraint extends Constraint {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RodConstraint";
	/** Current distance between the two attachments. Value in [0, inf).Current distance between the two attachments. Value in [0, inf). *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly CurrentDistance: number;
	/** The length of the rod or the distance to be maintained between the two attachments. Value in [0, inf). */
	Length: number;
	/** The thickness of the in-game visual (diameter). Value in [0, inf). */
	Thickness: number;
}

interface RopeConstraint extends Constraint {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RopeConstraint";
	/** Current distance between the two attachments. Value in [0, inf).Current distance between the two attachments. Value in [0, inf). *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly CurrentDistance: number;
	/** The length of the rope or the maximum distance between the two attachments. Value in [0, inf). */
	Length: number;
	/** Restitution of the rope, or how elastic it is. Value in [0, 1]. */
	Restitution: number;
	/** The thickness of the in-game visual (diameter). Value in [0, inf). */
	Thickness: number;
}

interface SlidingBallConstraint extends Constraint {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SlidingBallConstraint" | "CylindricalConstraint" | "PrismaticConstraint";
	/** Type of linear actuator (along the axis of the slider): None, Motor, or Servo. */
	ActuatorType: Enum.ActuatorType;
	/** Current position of Attachment1 with respect to Attachment0 along the slider axis. Value in (-inf, inf).Current position of Attachment1 with respect to Attachment0 along the slider axis. Value in (-inf, inf). *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly CurrentPosition: number;
	/** Enables the limits on the linear motion along the axis of the slider. */
	LimitsEnabled: boolean;
	/** Lower limit for the position of Attachment1 with respect to Attachment0 along the slider axis. Value in (-inf, inf). */
	LowerLimit: number;
	/** The maximum acceleration of the motor in studs per second squared. Value in [0, inf). */
	MotorMaxAcceleration: number;
	/** The maximum force the motor can apply to achieve the target velocity. Units are mass * studs / seconds^2. Value in [0, inf). */
	MotorMaxForce: number;
	/** Restitution of the two limits, or how elastic they are. Value in [0, 1]. */
	Restitution: number;
	/** Maximum force the servo motor can apply. Units are mass * studs / seconds^2. Value in [0, inf). */
	ServoMaxForce: number;
	/** Size of the in-game visual associated with this constraint. Value in [0, inf). */
	Size: number;
	/** Target speed in studs per second. This value is unsigned as the servo will always move toward its target. Value in [0, inf). */
	Speed: number;
	/** Target position of Attachment1 with respect to Attachment0 along the slider axis. Value in (-inf, inf). */
	TargetPosition: number;
	/** Upper limit for the position of Attachment1 with respect to Attachment0 along the slider axis. Value in (-inf, inf). */
	UpperLimit: number;
	/** The target linear velocity of the motor in studs per second along the slider axis. Value in (-inf, inf). */
	Velocity: number;
}

interface CylindricalConstraint extends SlidingBallConstraint {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CylindricalConstraint";
	/** Type of angular actuator: None, Motor, or Servo.  */
	AngularActuatorType: Enum.ActuatorType;
	/** Enables the angular limits around the rotation axis. */
	AngularLimitsEnabled: boolean;
	/** Restitution of the two limits, or how elastic they are. Value in [0, 1].  */
	AngularRestitution: number;
	/** Target angular speed. This value is unsigned as the servo will always move toward its target. In radians per second. Value in [0, inf).  */
	AngularSpeed: number;
	/** The target angular velocity of the motor in radians per second around the rotation axis. Value in [0, inf). */
	AngularVelocity: number;
	/** Signed angle (in degrees) between the reference axis and the secondary axis of Attachment1 around the rotation axis. Value in [-180, 180]. Signed angle (in degrees) between the reference axis and the secondary axis of Attachment1 around the rotation axis. Value in [-180, 180].  *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly CurrentAngle: number;
	/** Direction of the rotation axis as an angle from the x-axis in the xy-plane of Attachment0. Value in [-180, 180].  */
	InclinationAngle: number;
	/** Lower limit for the angle (in degrees) between the reference axis and the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180]. */
	LowerAngle: number;
	/** The maximum angular acceleration of the motor in radians per second squared. Value in [0, inf). */
	MotorMaxAngularAcceleration: number;
	/** The maximum torque the motor can apply to achieve the target angular velocity. The units are mass * studs^2 / second^2. Value in [0, inf). */
	MotorMaxTorque: number;
	/** Enable the visibility of the rotation axis. */
	RotationAxisVisible: boolean;
	/** Maximum torque the servo motor can apply. The units are mass * studs^2 / second^2. Value in [0, inf).  */
	ServoMaxTorque: number;
	/**  Target angle (in degrees) between the reference axis and the secondary axis of Attachment1 around the rotation axis. Value in [-180, 180]. */
	TargetAngle: number;
	/** Upper limit for the angle (in degrees) between the reference axis and the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180].  */
	UpperAngle: number;
	/** The unit vector direction of the rotation axis in world coordinates.The unit vector direction of the rotation axis in world coordinates. *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly WorldRotationAxis: Vector3;
}

interface PrismaticConstraint extends SlidingBallConstraint {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PrismaticConstraint";
}

interface SpringConstraint extends Constraint {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SpringConstraint";
	/** The number of coils in the in-game visual. Value in [0, 8]. */
	Coils: number;
	/** Current distance between the two attachments. Value in [0, inf).Current distance between the two attachments. Value in [0, inf). *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly CurrentLength: number;
	/** The damping parameter of the spring. The force is scaled with respect to relative velocity. The units of this property are force / velocity. Value in [0, inf). */
	Damping: number;
	/** The distance (in studs) between the two attachments at which the spring exerts no stiffness force. Value in [0, inf). */
	FreeLength: number;
	/** Enables limits on the length of the spring. */
	LimitsEnabled: boolean;
	/** The maximum force that the spring can apply. Useful to prevent instabilities. The units are mass * studs / seconds^2. Value in [0, inf). */
	MaxForce: number;
	/** Maximum spring length, or the maxium distance between the two attachments. Value in [0, inf). */
	MaxLength: number;
	/** Minimum spring length, or the minimum distance between the two attachments. Value in [0, inf). */
	MinLength: number;
	/** The radius of the in-game spring coil visual. Value in [0, inf). */
	Radius: number;
	/** The stiffness parameter of the spring. Force is scaled based on distance from the free length. The units of this property are force / distance. Value in [0, inf). */
	Stiffness: number;
	/** The thickness of the spring wire (diameter) in the in-game visual. Value in [0, inf). */
	Thickness: number;
}

interface Torque extends Constraint {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Torque";
	/** [NO DOCUMENTATION] */
	RelativeTo: Enum.ActuatorRelativeTo;
	/** [NO DOCUMENTATION] */
	Torque: Vector3;
}

interface VectorForce extends Constraint {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "VectorForce";
	/** [NO DOCUMENTATION] */
	ApplyAtCenterOfMass: boolean;
	/** [NO DOCUMENTATION] */
	Force: Vector3;
	/** [NO DOCUMENTATION] */
	RelativeTo: Enum.ActuatorRelativeTo;
}

interface ContentProvider extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ContentProvider";
	readonly BaseUrl: string;
	readonly RequestQueueSize: number;

	PreloadAsync(contentIdList: Array<Instance>): void;
}

/** @rbxts client */
interface ContextActionService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ContextActionService";
	/** Binds 'functionToBind' to fire when any 'inputTypes' happen. InputTypes can be variable in number and type. Types can be Enum.KeyCode, single character strings corresponding to keys, or Enum.UserInputType. 'actionName' is a key used by many other ContextActionService functions to query state. 'createTouchButton' if true will create a button on screen on touch devices.  This button will fire 'functionToBind' with three arguments: first argument is the actionName, second argument is the UserInputState of the input, and the third is the InputObject that fired this function. If 'functionToBind' yields or returns nil or Enum.ContextActionResult.Sink, the input will be sunk. If it returns Enum.ContextActionResult.Pass, the next bound action in the stack will be invoked. */
	BindAction(
		actionName: string,
		functionToBind: (actionName: string, state: Enum.UserInputState, inputObject: InputObject) => void,
		createTouchButton: boolean,
		...inputTypes: Array<Enum.KeyCode | Enum.PlayerActions | Enum.UserInputType>
	): void;

	BindActionAtPriority(
		actionName: string,
		functionToBind: (actionName: string, state: Enum.UserInputState, inputObject: InputObject) => void,
		createTouchButton: boolean,
		priorityLevel: number,
		...inputTypes: Array<Enum.KeyCode | Enum.PlayerActions | Enum.UserInputType>
	): void;
	BindActivate(userInputTypeForActivation: CastsToEnum<Enum.UserInputType>, keyCodeForActivation?: CastsToEnum<Enum.KeyCode>): void;
	/** Returns a table with all bound action info. Each entry is a key with 'actionName' and value being the same table you would get from ContextActionService:GetBoundActionInfo('actionName'). */
	GetAllBoundActionInfo(): Map<string, BoundActionInfo>;
	/** Returns a table with info regarding the function bound with 'actionName'. Table has the keys 'title' (current title that was set with SetTitle) 'image' (image set with SetImage) 'description' (description set with SetDescription) 'inputTypes' (tuple containing all input bound for this 'actionName') 'createTouchButton' (whether or not we created a touch button for this 'actionName').  */
	GetBoundActionInfo(actionName: string): BoundActionInfo;
	GetCurrentLocalToolIcon(): string;
	/** If 'actionName' key contains a bound action, then 'description' is set as the description of the bound action. This description will appear for users in a listing of current actions availables. */
	SetDescription(actionName: string, description: string): void;
	/** If 'actionName' key contains a bound action, then 'image' is set as the image of the touch button. Does nothing if a touch button was not created. No guarantees are made whether image will be set when button is manipulated. */
	SetImage(actionName: string, image: string): void;
	/** If 'actionName' key contains a bound action, then 'position' is set as the position of the touch button. Does nothing if a touch button was not created. No guarantees are made whether position will be set when button is manipulated. */
	SetPosition(actionName: string, position: UDim2): void;
	/** If 'actionName' key contains a bound action, then 'title' is set as the title of the touch button. Does nothing if a touch button was not created. No guarantees are made whether title will be set when button is manipulated. */
	SetTitle(actionName: string, title: string): void;
	/** If 'actionName' key contains a bound action, removes function from being called by all input that it was bound by (if function was also bound by a different action name as well, those bound input are still active). Will also remove any touch button created (if button was manipulated manually there is no guarantee it will be cleaned up). */
	UnbindAction(actionName: string): void;
	UnbindActivate(userInputTypeForActivation: CastsToEnum<Enum.UserInputType>, keyCodeForActivation?: CastsToEnum<Enum.KeyCode>): void;
	/** Removes all functions bound. No actionNames will remain. All touch buttons will be removed. If button was manipulated manually there is no guarantee it will be cleaned up. */
	UnbindAllActions(): void;
	/** If 'actionName' key contains a bound action, then this will return the touch button (if was created). Returns nil if a touch button was not created. No guarantees are made whether button will be retrievable when button is manipulated. */
	GetButton(actionName: string): ImageButton | undefined;

	readonly LocalToolEquipped: RBXScriptSignal<(toolEquipped: Tool | Flag) => void>;

	readonly LocalToolUnequipped: RBXScriptSignal<(toolUnequipped: Tool | Flag) => void>;
}

interface Controller extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Controller" | "HumanoidController" | "SkateboardController" | "VehicleController";
	/** [NO DOCUMENTATION] */
	BindButton(button: CastsToEnum<Enum.Button>, caption: string): void;
	/** [NO DOCUMENTATION] */
	GetButton(button: CastsToEnum<Enum.Button>): boolean;
	/** [NO DOCUMENTATION] */
	UnbindButton(button: CastsToEnum<Enum.Button>): void;
	/** [NO DOCUMENTATION] */
	readonly ButtonChanged: RBXScriptSignal<(button: Enum.Button) => void>;
}

interface HumanoidController extends Controller {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "HumanoidController";
}

interface SkateboardController extends Controller {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SkateboardController";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Steer: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Throttle: number;
	/** [NO DOCUMENTATION] */
	readonly AxisChanged: RBXScriptSignal<(axis: string) => void>;
}

interface VehicleController extends Controller {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "VehicleController";
}

interface ControllerService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ControllerService";
}

interface CookiesService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CookiesService";
}

interface CorePackages extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CorePackages";
}

interface CoreScriptSyncService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CoreScriptSyncService";
}

interface CustomEvent extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CustomEvent";
	/** [NO DOCUMENTATION] */
	GetAttachedReceivers(): Array<Instance>;
	/** [NO DOCUMENTATION] */
	SetValue(newValue: number): void;
	/** [NO DOCUMENTATION] */
	readonly ReceiverConnected: RBXScriptSignal<(receiver: Instance) => void>;
	/** [NO DOCUMENTATION] */
	readonly ReceiverDisconnected: RBXScriptSignal<(receiver: Instance) => void>;
}

interface CustomEventReceiver extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CustomEventReceiver";
	/** [NO DOCUMENTATION] */
	Source?: Instance;
	/** [NO DOCUMENTATION] */
	GetCurrentValue(): number;
	/** [NO DOCUMENTATION] */
	readonly EventConnected: RBXScriptSignal<(event: Instance) => void>;
	/** [NO DOCUMENTATION] */
	readonly EventDisconnected: RBXScriptSignal<(event: Instance) => void>;
	/** [NO DOCUMENTATION] */
	readonly SourceValueChanged: RBXScriptSignal<(newValue: number) => void>;
}

interface DataModelMesh extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "DataModelMesh" | "BevelMesh" | "FileMesh" | "BlockMesh" | "CylinderMesh" | "SpecialMesh";
	/** [NO DOCUMENTATION] */
	Offset: Vector3;
	/** [NO DOCUMENTATION] */
	Scale: Vector3;
	/** [NO DOCUMENTATION] */
	VertexColor: Vector3;
}

interface BevelMesh extends DataModelMesh {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BevelMesh" | "BlockMesh" | "CylinderMesh";
}

interface BlockMesh extends BevelMesh {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BlockMesh";
}

interface CylinderMesh extends BevelMesh {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CylinderMesh";
}

interface FileMesh extends DataModelMesh {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "FileMesh" | "SpecialMesh";
	/** [NO DOCUMENTATION] */
	MeshId: string;
	/** [NO DOCUMENTATION] */
	TextureId: string;
}

interface SpecialMesh extends FileMesh {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SpecialMesh";
	/** [NO DOCUMENTATION] */
	MeshType: Enum.MeshType;
}

/** @rbxts server */
interface DataStoreService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "DataStoreService";
	/** Returns a data store with the given name and scope */
	GetDataStore(name: string, scope?: string): GlobalDataStore;
	/** Returns the default data store */
	GetGlobalDataStore(): GlobalDataStore;
	/** Returns an ordered data store with the given name and scope */
	GetOrderedDataStore(name: string, scope?: string): OrderedDataStore;
	GetRequestBudgetForRequestType(requestType: CastsToEnum<Enum.DataStoreRequestType>): number;
}

interface Debris extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Debris";
	/** Adds an Instance into the debris service that will later be destroyed.  Second argument 'lifetime' is optional and specifies how long (in seconds) to wait before destroying the item. If no time is specified then the item added will automatically be destroyed in 10 seconds. */
	AddItem(item: Instance, lifetime?: number): void;
}

interface DebugSettings extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "DebugSettings";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly DataModel: number;
	/** [NO DOCUMENTATION] */
	ErrorReporting: Enum.ErrorReporting;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly GfxCard: string;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly InstanceCount: number;
	/** [NO DOCUMENTATION] */
	IsFmodProfilingEnabled: boolean;
	/** [NO DOCUMENTATION] */
	IsScriptStackTracingEnabled: boolean;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly JobCount: number;
	/** [NO DOCUMENTATION] */
	LuaRamLimit: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly OsIs64Bit: boolean;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly OsPlatform: string;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly OsPlatformId: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly OsVer: string;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly PlayerCount: number;
	/** [NO DOCUMENTATION] */
	ReportSoundWarnings: boolean;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly RobloxProductName: string;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly RobloxVersion: string;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly SIMD: string;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly SystemProductName: string;
	/** [NO DOCUMENTATION] */
	TickCountPreciseOverride: Enum.TickCountSampleMethod;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly VideoMemory: number;
}

interface DebuggerBreakpoint extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "DebuggerBreakpoint";
	/** [NO DOCUMENTATION] */
	Condition: string;
	/** [NO DOCUMENTATION] */
	IsEnabled: boolean;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Line: number;
}

interface DebuggerManager extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "DebuggerManager";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly DebuggingEnabled: boolean;
	/** [NO DOCUMENTATION] */
	AddDebugger(script: Instance): Instance | undefined;
	/** [NO DOCUMENTATION] */
	GetDebuggers(): Array<Instance>;
	/** [NO DOCUMENTATION] */
	Resume(): void;
	/** [NO DOCUMENTATION] */
	StepIn(): void;
	/** [NO DOCUMENTATION] */
	StepOut(): void;
	/** [NO DOCUMENTATION] */
	StepOver(): void;
	/** [NO DOCUMENTATION] */
	readonly DebuggerAdded: RBXScriptSignal<(debug: Instance) => void>;
	/** [NO DOCUMENTATION] */
	readonly DebuggerRemoved: RBXScriptSignal<(debug: Instance) => void>;
}

interface DebuggerWatch extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "DebuggerWatch";
	/** [NO DOCUMENTATION] */
	Expression: string;
	/** [NO DOCUMENTATION] */
	CheckSyntax(): void;
}

interface Dialog extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Dialog";
	/** Indicates how the dialog may be used by players. Use Enum.DialogBehaviorType.SinglePlayer if only one player should interact with the dialog at a time, otherwise use Enum.DialogBehaviorType.MultiplePlayers. */
	BehaviorType: Enum.DialogBehaviorType;
	/** The maximum distance that the player's character can be from the dialog's parent in order to use the dialog. */
	ConversationDistance: number;
	/** Indicates whether or not an extra choice is available for the player to exit the dialog tree at this node. */
	GoodbyeChoiceActive: boolean;
	/** The prompt text for an extra choice that allows the player to exit the dialog tree at this node. */
	GoodbyeDialog: string;
	/** Indicates whether or not the dialog is currently being used by one or more players. */
	InUse: boolean;
	/** The chat message that is displayed to the player when they first activate the dialog. */
	InitialPrompt: string;
	/** Describes the purpose of the dialog, which is used to display a relevant icon on the dialog's activation button. */
	Purpose: Enum.DialogPurpose;
	/** Describes the tone of the dialog, which is used to display a relevant color in the dialog interface. */
	Tone: Enum.DialogTone;
	TriggerDistance: number;
	TriggerOffset: Vector3;
	/** Returns an array of the players currently conversing with this dialog. */
	GetCurrentPlayers(): Array<Player>;

	readonly DialogChoiceSelected: RBXScriptSignal<(player: Player, dialogChoice: Dialog) => void>;
}

interface DialogChoice extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "DialogChoice";
	/** [NO DOCUMENTATION] */
	GoodbyeChoiceActive: boolean;
	/** [NO DOCUMENTATION] */
	GoodbyeDialog: string;
	/** [NO DOCUMENTATION] */
	ResponseDialog: string;
	/** [NO DOCUMENTATION] */
	UserDialog: string;
}

interface Dragger extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Dragger";
	AxisRotate(axis?: CastsToEnum<Enum.Axis>): void;

	MouseDown(mousePart: BasePart, pointOnMousePart: Vector3, parts: Array<BasePart>): void;
	MouseMove(mouseRay: Ray): void;
	MouseUp(): void;
}

interface Explosion extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Explosion";
	/** How much force this Explosion exerts on objects within it's BlastRadius. Setting this to 0 creates a purely graphical effect. A larger number will cause Parts to fly away at higher velocities. */
	BlastPressure: number;
	/** How big the Explosion is. This is a circle starting from the center of the Explosion's Position, the larger this property the larger the circle of destruction. */
	BlastRadius: number;
	DestroyJointRadiusPercent: number;
	/** Defines the behavior of the Explosion. [More info](http://wiki.roblox.com/index.php/ExplosionType) */
	ExplosionType: Enum.ExplosionType;
	/** Where the Explosion occurs in absolute world coordinates. */
	Position: Vector3;
	Visible: boolean;

	readonly Hit: RBXScriptSignal<(part: BasePart, distance: number) => void>;
}

interface FaceInstance extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "FaceInstance" | "Decal" | "Texture";
	/** [NO DOCUMENTATION] */
	Face: Enum.NormalId;
}

interface Decal extends FaceInstance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Decal" | "Texture";
	/** [NO DOCUMENTATION] */
	Color3: Color3;
	/** [NO DOCUMENTATION] *
	 * Tags: Hidden, NotReplicated
	 */
	LocalTransparencyModifier: number;
	/** [NO DOCUMENTATION] */
	Texture: string;
	/** How visible the decal is.  1 is completely invisible, while 0 is completely opaque */
	Transparency: number;
}

interface Texture extends Decal {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Texture";
	/** [NO DOCUMENTATION] */
	StudsPerTileU: number;
	/** [NO DOCUMENTATION] */
	StudsPerTileV: number;
}

interface Feature extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Feature" | "Hole" | "MotorFeature";
	/** [NO DOCUMENTATION] */
	FaceId: Enum.NormalId;
	/** [NO DOCUMENTATION] */
	InOut: Enum.InOut;
	/** [NO DOCUMENTATION] */
	LeftRight: Enum.LeftRight;
	/** [NO DOCUMENTATION] */
	TopBottom: Enum.TopBottom;
}

interface Hole extends Feature {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Hole";
}

interface MotorFeature extends Feature {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "MotorFeature";
}

interface File extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "File";
}

interface Fire extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Fire";
	/** The color of the base of the fire.  See SecondaryColor for more. */
	Color: Color3;
	/** [NO DOCUMENTATION] */
	Enabled: boolean;
	/** How hot the fire appears to be. The flame moves quicker the higher this value is set.How hot the fire appears to be. The flame moves quicker the higher this value is set. *
	 * Tags: NotReplicated
	 */
	Heat: number;
	/** The color the fire interpolates to from Color. The longer a particle exists in the fire, the close to this color it becomes. */
	SecondaryColor: Color3;
	/** How large the fire appears to be.How large the fire appears to be. *
	 * Tags: NotReplicated
	 */
	Size: number;
}

interface FlagStandService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "FlagStandService";
}

interface FlyweightService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "FlyweightService" | "CSGDictionaryService" | "NonReplicatedCSGDictionaryService";
}

interface CSGDictionaryService extends FlyweightService {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CSGDictionaryService";
}

interface NonReplicatedCSGDictionaryService extends FlyweightService {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "NonReplicatedCSGDictionaryService";
}

interface Folder extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Folder";
}

interface ForceField extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ForceField";
	/** [NO DOCUMENTATION] */
	Visible: boolean;
}

interface FriendService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "FriendService";
}

interface FunctionalTest extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "FunctionalTest";
	/** [NO DOCUMENTATION] */
	Description: string;
	/** [NO DOCUMENTATION] */
	Error(message?: string): void;
	/** [NO DOCUMENTATION] */
	Failed(message?: string): void;
	/** [NO DOCUMENTATION] */
	Pass(message?: string): void;
	/** [NO DOCUMENTATION] */
	Passed(message?: string): void;
	/** [NO DOCUMENTATION] */
	Warn(message?: string): void;
}

interface GamePassService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "GamePassService";
}

interface GameSettings extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "GameSettings";
	/** [NO DOCUMENTATION] */
	AdditionalCoreIncludeDirs: string;
	/** [NO DOCUMENTATION] */
	BubbleChatLifetime: number;
	/** [NO DOCUMENTATION] */
	BubbleChatMaxBubbles: number;
	/** [NO DOCUMENTATION] */
	ChatHistory: number;
	/** [NO DOCUMENTATION] */
	ChatScrollLength: number;
	/** [NO DOCUMENTATION] */
	HardwareMouse: boolean;
	/** [NO DOCUMENTATION] */
	OverrideStarterScript: string;
	/** [NO DOCUMENTATION] */
	ReportAbuseChatHistory: number;
	/** [NO DOCUMENTATION] */
	SoftwareSound: boolean;
	/** [NO DOCUMENTATION] */
	VideoCaptureEnabled: boolean;
	/** [NO DOCUMENTATION] */
	VideoQuality: Enum.VideoQualitySettings;
}

interface GamepadService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "GamepadService";
}

interface Geometry extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Geometry";
}

/** @rbxts server */
interface GlobalDataStore extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "GlobalDataStore" | "OrderedDataStore";
	/** Sets callback as a function to be executed any time the value associated with key is changed. It is important to disconnect the connection when the subscription to the key is no longer needed.  */
	OnUpdate<T = unknown>(key: string, callback: (value: T) => void): RBXScriptConnection;
	/** Returns the value of the entry in the DataStore with the given key */
	GetAsync<T = unknown>(key: string): T | undefined;
	/** Increments the value of a particular key amd returns the incremented value */
	IncrementAsync(key: string, delta?: number): number;

	RemoveAsync<T = unknown>(key: string): T | undefined;
	/** Sets the value of the key. This overwrites any existing data stored in the key */
	SetAsync(key: string, value?: any): void;
	/** Retrieves the value of the key from the website, and updates it with a new value. The callback until the value fetched matches the value on the web. Returning nil means it will not save.  */
	UpdateAsync<O = unknown, R = unknown>(
		key: string,
		transformFunction: (oldValue: O | undefined) => R,
	): R extends undefined ? O | undefined : R;
}

/** @rbxts server */
interface OrderedDataStore extends GlobalDataStore {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "OrderedDataStore";
	/** Returns a DataStorePages object. The length of each page is determined by pageSize, and the order is determined by isAscending. minValue and maxValue are optional parameters which will filter the result.  */
	GetSortedAsync(ascending: boolean, pagesize: number, minValue?: number, maxValue?: number): DataStorePages;
}

interface GoogleAnalyticsConfiguration extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "GoogleAnalyticsConfiguration";
}

interface GroupService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "GroupService";

	GetAlliesAsync(groupId: number): StandardPages;

	GetEnemiesAsync(groupId: number): StandardPages;

	GetGroupInfoAsync(groupId: number): GroupInfo;

	GetGroupsAsync(userId: number): Array<GetGroupsAsyncResult>;
}

interface GuiBase extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "GuiBase" | "GuiBase2d" | "GuiBase3d" | "GuiObject" | "LayerCollector" | "Frame" | "GuiButton" | "GuiLabel" | "ScrollingFrame" | "TextBox" | "ViewportFrame" | "ImageButton" | "TextButton" | "ImageLabel" | "TextLabel" | "BillboardGui" | "PluginGui" | "ScreenGui" | "SurfaceGui" | "DockWidgetPluginGui" | "QWidgetPluginGui" | "GuiMain" | "FloorWire" | "PVAdornment" | "PartAdornment" | "SelectionLasso" | "HandleAdornment" | "ParabolaAdornment" | "SelectionBox" | "SelectionSphere" | "BoxHandleAdornment" | "ConeHandleAdornment" | "CylinderHandleAdornment" | "ImageHandleAdornment" | "LineHandleAdornment" | "SphereHandleAdornment" | "HandlesBase" | "SurfaceSelection" | "ArcHandles" | "Handles" | "SelectionPartLasso" | "SelectionPointLasso";
}

interface GuiBase2d extends GuiBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "GuiBase2d" | "GuiObject" | "LayerCollector" | "Frame" | "GuiButton" | "GuiLabel" | "ScrollingFrame" | "TextBox" | "ViewportFrame" | "ImageButton" | "TextButton" | "ImageLabel" | "TextLabel" | "BillboardGui" | "PluginGui" | "ScreenGui" | "SurfaceGui" | "DockWidgetPluginGui" | "QWidgetPluginGui" | "GuiMain";
	/** A read-only Vector2 value that is the GuiObject's current position (x,y) in pixel space, from the top left corner of the GuiObject.A read-only Vector2 value that is the GuiObject's current position (x,y) in pixel space, from the top left corner of the GuiObject. *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly AbsolutePosition: Vector2;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly AbsoluteRotation: number;
	/** A read-only Vector2 value that is the GuiObject's current size (width, height) in pixel space.A read-only Vector2 value that is the GuiObject's current size (width, height) in pixel space. *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly AbsoluteSize: Vector2;
	/** [NO DOCUMENTATION] */
	AutoLocalize: boolean;
	/** [NO DOCUMENTATION] */
	RootLocalizationTable?: LocalizationTable;
}

interface GuiObject extends GuiBase2d {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "GuiObject" | "Frame" | "GuiButton" | "GuiLabel" | "ScrollingFrame" | "TextBox" | "ViewportFrame" | "ImageButton" | "TextButton" | "ImageLabel" | "TextLabel";
	/** If true, this GuiObject can fire mouse events and will pass them to any GuiObjects layered underneath, while false will do neither. */
	Active: boolean;
	AnchorPoint: Vector2;
	/** A Color3 value that specifies the background color for the GuiObject. This value is ignored if the Style property (not found on all GuiObjects) is set to something besides custom. */
	BackgroundColor3: Color3;
	/** A number value that specifies how transparent the background of the GuiObject is. This value is ignored if the Style property (not found on all GuiObjects) is set to something besides custom. */
	BackgroundTransparency: number;
	/** A Color3 value that specifies the color of the outline of the GuiObject. This value is ignored if the Style property (not found on all GuiObjects) is set to something besides custom. */
	BorderColor3: Color3;
	/** A number value that specifies the thickness (in pixels) of the outline of the GuiObject. Currently this value can only be set to either 0 or 1, any other number has no effect. This value is ignored if the Style property (not found on all GuiObjects) is set to something besides custom. */
	BorderSizePixel: number;
	/** If set to true, any descendants of this GuiObject will only render if contained within it's borders. If set to false, all descendants will render regardless of position. */
	ClipsDescendants: boolean;
	LayoutOrder: number;
	NextSelectionDown?: GuiObject;
	NextSelectionLeft?: GuiObject;
	NextSelectionRight?: GuiObject;
	NextSelectionUp?: GuiObject;
	/** A UDim2 value describing the position of the top-left corner of the GuiObject on screen. More information on UDim2 is available [here](http://wiki.roblox.com/index.php/UDim2). */
	Position: UDim2;
	Rotation: number;
	Selectable: boolean;
	/** Overrides the default selection adornment (used for gamepads). For best results, this should point to a GuiObject. */
	SelectionImageObject?: GuiObject;
	/** A UDim2 value describing the size of the GuiObject on screen in both absolute and relative coordinates. More information on UDim2 is available [here](http://wiki.roblox.com/index.php/UDim2). */
	Size: UDim2;
	/** The direction(s) that an object can be resized in. [More info](http://wiki.roblox.com/index.php/SizeConstraint). */
	SizeConstraint: Enum.SizeConstraint;
	Transparency: number;
	Visible: boolean;
	/** Describes the ordering in which overlapping GuiObjects will be drawn. A value of 1 is drawn first, while higher values are drawn in ascending order (each value draws over the last). */
	ZIndex: number;
	/** Smoothly moves a GuiObject from its current position to 'endPosition'. The only required argument is 'endPosition'. [More info](http://wiki.roblox.com/index.php/TweenPosition)  */
	TweenPosition(
		endPosition: UDim2,
		easingDirection?: CastsToEnum<Enum.EasingDirection>,
		easingStyle?: CastsToEnum<Enum.EasingStyle>,
		time?: number,
		override?: boolean,
		callback?: (finishedTween: Enum.TweenStatus) => void,
	): boolean;
	/** Smoothly translates a GuiObject's current size to 'endSize'. The only required argument is 'endSize'. [More info](http://wiki.roblox.com/index.php/TweenSize)  */
	TweenSize(
		endSize: UDim2,
		easingDirection?: CastsToEnum<Enum.EasingDirection>,
		easingStyle?: CastsToEnum<Enum.EasingStyle>,
		time?: number,
		override?: boolean,
		callback?: (finishedTween: Enum.TweenStatus) => void,
	): boolean;
	/** Smoothly translates a GuiObject's current size to 'endSize', and also smoothly translates the GuiObject's current position to 'endPosition'. The only required arguments are 'endSize' and 'endPosition'. [More info](http://wiki.roblox.com/index.php/TweenSizeAndPosition)  */
	TweenSizeAndPosition(
		endSize: UDim2,
		endPosition: UDim2,
		easingDirection?: CastsToEnum<Enum.EasingDirection>,
		easingStyle?: CastsToEnum<Enum.EasingStyle>,
		time?: number,
		override?: boolean,
		callback?: (finishedTween: Enum.TweenStatus) => void,
	): boolean;
	/** Fired when a user begins interacting via a Human-Computer Interface device (Mouse button down, touch begin, keyboard button down, etc.). 'inputObject' is an InputObject, which contains useful data for querying user input.  This event only fires locally. */
	readonly InputBegan: RBXScriptSignal<(input: InputObject) => void>;
	/** Fired when a user changes interacting via a Human-Computer Interface device (Mouse move, touch move, mouse wheel, etc.). 'inputObject' is an InputObject, which contains useful data for querying user input.  This event only fires locally. */
	readonly InputChanged: RBXScriptSignal<(input: InputObject) => void>;
	/** Fired when a user stops interacting via a Human-Computer Interface device (Mouse button up, touch end, keyboard button up, etc.). 'inputObject' is an InputObject, which contains useful data for querying user input.  This event only fires locally. */
	readonly InputEnded: RBXScriptSignal<(input: InputObject) => void>;
	/** Fired when the mouse enters a GuiObject, as long as the GuiObject is active (see active property for more detail). Arguments 'x', and 'y' specify the absolute pixel position of the mouse. */
	readonly MouseEnter: RBXScriptSignal<(x: number, y: number) => void>;
	/** Fired when the mouse leaves a GuiObject, as long as the GuiObject is active (see active property for more detail). Arguments 'x', and 'y' specify the absolute pixel position of the mouse. */
	readonly MouseLeave: RBXScriptSignal<(x: number, y: number) => void>;
	/** Fired when the mouse is inside a GuiObject and moves, as long as the GuiObject is active (see active property for more detail). Arguments 'x', and 'y' specify the absolute pixel position of the mouse. */
	readonly MouseMoved: RBXScriptSignal<(x: number, y: number) => void>;
	readonly MouseWheelBackward: RBXScriptSignal<(x: number, y: number) => void>;
	readonly MouseWheelForward: RBXScriptSignal<(x: number, y: number) => void>;
	readonly SelectionGained: RBXScriptSignal<() => void>;
	readonly SelectionLost: RBXScriptSignal<() => void>;
	/** Fired when a user holds at least one finger for a short amount of time on the same screen position on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the gesture. 'state' indicates the Enum.UserInputState of the gesture.  This event only fires locally. */
	readonly TouchLongPress: RBXScriptSignal<(touchPositions: Array<Vector2>, state: Enum.UserInputState) => void>;
	/** Fired when a user drags at least one finger on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the gesture. 'totalTranslation' is a Vector2, indicating how far the pan gesture has gone from its starting point. 'velocity' is a Vector2 that indicates how quickly the gesture is being performed in each dimension. 'state' indicates the Enum.UserInputState of the gesture. */
	readonly TouchPan: RBXScriptSignal<
		(
			touchPositions: Array<Vector2>,
			totalTranslation: Vector2,
			velocity: Vector2,
			state: Enum.UserInputState,
		) => void
	>;
	/** Fired when a user pinches their fingers on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the pinch gesture. 'scale' is a float that indicates the difference from the beginning of the pinch gesture. 'velocity' is a float indicating how quickly the pinch gesture is happening. 'state' indicates the Enum.UserInputState of the gesture.  This event only fires locally. */
	readonly TouchPinch: RBXScriptSignal<
		(touchPositions: Array<Vector2>, scale: number, velocity: number, state: Enum.UserInputState) => void
	>;
	/** Fired when a user rotates two fingers on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the gesture. 'rotation' is a float indicating how much the rotation has gone from the start of the gesture. 'velocity' is a float that indicates how quickly the gesture is being performed. 'state' indicates the Enum.UserInputState of the gesture.  This event only fires locally. */
	readonly TouchRotate: RBXScriptSignal<
		(touchPositions: Array<Vector2>, rotation: number, velocity: number, state: Enum.UserInputState) => void
	>;
	/** Fired when a user swipes their fingers on a TouchEnabled device. 'swipeDirection' is an Enum.SwipeDirection, indicating the direction the user swiped. 'numberOfTouches' is an int that indicates how many touches were involved with the gesture.  This event only fires locally. */
	readonly TouchSwipe: RBXScriptSignal<(swipeDirection: Enum.SwipeDirection, numberOfTouches: number) => void>;
	/** Fired when a user taps their finger on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the tap gesture. This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchTap: RBXScriptSignal<(touchPositions: Array<Vector2>) => void>;
}

interface Frame extends GuiObject {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Frame";
	/** Determines how a frame will look. Uses Enum.FrameStyle. [More info](http://wiki.roblox.com/index.php?title=API:Enum/FrameStyle) */
	Style: Enum.FrameStyle;
}

interface GuiButton extends GuiObject {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "GuiButton" | "ImageButton" | "TextButton";
	/** Determines whether a button changes color automatically when reacting to mouse events. */
	AutoButtonColor: boolean;
	/** Allows the mouse to be free in first person mode. If a button with this property set to true is visible, the mouse is 'free' in first person mode. */
	Modal: boolean;
	Selected: boolean;
	/** Determines how a button will look, including mouse event states. Uses Enum.ButtonStyle. [More info](http://wiki.roblox.com/index.php?title=API:Class/GuiButton/Style) */
	Style: Enum.ButtonStyle;

	readonly Activated: RBXScriptSignal<(inputObject: InputObject) => void>;
	/** Fired when the mouse is over the button, and the mouse down and up events fire without the mouse leaving the button. */
	readonly MouseButton1Click: RBXScriptSignal<() => void>;
	/** Fired when the mouse button is pushed down on a button. */
	readonly MouseButton1Down: RBXScriptSignal<(x: number, y: number) => void>;
	/** Fired when the mouse button is released on a button. */
	readonly MouseButton1Up: RBXScriptSignal<(x: number, y: number) => void>;
	/** This function currently does not work :( */
	readonly MouseButton2Click: RBXScriptSignal<() => void>;
	/** This function currently does not work :( */
	readonly MouseButton2Down: RBXScriptSignal<(x: number, y: number) => void>;
	/** This function currently does not work :( */
	readonly MouseButton2Up: RBXScriptSignal<(x: number, y: number) => void>;
}

interface ImageButton extends GuiButton {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ImageButton";
	/** [NO DOCUMENTATION] */
	HoverImage: string;
	/** Specifies the asset id of the texture to display. [More info](http://wiki.roblox.com/index.php?title=API:Class/ImageButton/Image)  */
	Image: string;
	/** [NO DOCUMENTATION] */
	ImageColor3: Color3;
	/** [NO DOCUMENTATION] */
	ImageRectOffset: Vector2;
	/** [NO DOCUMENTATION] */
	ImageRectSize: Vector2;
	/** [NO DOCUMENTATION] */
	ImageTransparency: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly IsLoaded: boolean;
	/** [NO DOCUMENTATION] */
	PressedImage: string;
	/** Specifies how an image should be displayed. See ScaleType for more info. */
	ScaleType: Enum.ScaleType;
	/** If ScaleType is set to Slice, this Rect is used to specify the central part of the image. Everything outside of this is considered to be the border. */
	SliceCenter: Rect;
	/** [NO DOCUMENTATION] */
	SliceScale: number;
	/** If ScaleType is set to Tile, this sets the size of the tile. */
	TileSize: UDim2;
}

interface TextButton extends GuiButton {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TextButton";
	/** [NO DOCUMENTATION] */
	Font: Enum.Font;
	/** [NO DOCUMENTATION] */
	LineHeight: number;
	/** [NO DOCUMENTATION] *
	 * Tags: Hidden, ReadOnly, NotReplicated
	 */
	readonly LocalizedText: string;
	/** [NO DOCUMENTATION] */
	Text: string;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly TextBounds: Vector2;
	/** [NO DOCUMENTATION] */
	TextColor3: Color3;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly TextFits: boolean;
	/** [NO DOCUMENTATION] */
	TextScaled: boolean;
	/** [NO DOCUMENTATION] */
	TextSize: number;
	/** [NO DOCUMENTATION] */
	TextStrokeColor3: Color3;
	/** [NO DOCUMENTATION] */
	TextStrokeTransparency: number;
	/** [NO DOCUMENTATION] */
	TextTransparency: number;
	/** [NO DOCUMENTATION] */
	TextTruncate: Enum.TextTruncate;
	/** [NO DOCUMENTATION] */
	TextWrapped: boolean;
	/** [NO DOCUMENTATION] */
	TextXAlignment: Enum.TextXAlignment;
	/** [NO DOCUMENTATION] */
	TextYAlignment: Enum.TextYAlignment;
}

interface GuiLabel extends GuiObject {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "GuiLabel" | "ImageLabel" | "TextLabel";
}

interface ImageLabel extends GuiLabel {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ImageLabel";
	/** Specifies the id of the texture to display. [More info](http://wiki.roblox.com/index.php?title=API:Class/ImageLabel/Image) */
	Image: string;
	/** [NO DOCUMENTATION] */
	ImageColor3: Color3;
	/** [NO DOCUMENTATION] */
	ImageRectOffset: Vector2;
	/** [NO DOCUMENTATION] */
	ImageRectSize: Vector2;
	/** [NO DOCUMENTATION] */
	ImageTransparency: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly IsLoaded: boolean;
	/** Specifies how an image should be displayed. See ScaleType for more info. */
	ScaleType: Enum.ScaleType;
	/** If ScaleType is set to Slice, this Rect is used to specify the central part of the image. Everything outside of this is considered to be the border. */
	SliceCenter: Rect;
	/** [NO DOCUMENTATION] */
	SliceScale: number;
	/** If ScaleType is set to Tile, this sets the size of the tile. */
	TileSize: UDim2;
}

interface TextLabel extends GuiLabel {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TextLabel";
	/** [NO DOCUMENTATION] */
	Font: Enum.Font;
	/** [NO DOCUMENTATION] */
	LineHeight: number;
	/** [NO DOCUMENTATION] *
	 * Tags: Hidden, ReadOnly, NotReplicated
	 */
	readonly LocalizedText: string;
	/** [NO DOCUMENTATION] */
	Text: string;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly TextBounds: Vector2;
	/** [NO DOCUMENTATION] */
	TextColor3: Color3;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly TextFits: boolean;
	/** [NO DOCUMENTATION] */
	TextScaled: boolean;
	/** [NO DOCUMENTATION] */
	TextSize: number;
	/** [NO DOCUMENTATION] */
	TextStrokeColor3: Color3;
	/** [NO DOCUMENTATION] */
	TextStrokeTransparency: number;
	/** [NO DOCUMENTATION] */
	TextTransparency: number;
	/** [NO DOCUMENTATION] */
	TextTruncate: Enum.TextTruncate;
	/** [NO DOCUMENTATION] */
	TextWrapped: boolean;
	/** [NO DOCUMENTATION] */
	TextXAlignment: Enum.TextXAlignment;
	/** [NO DOCUMENTATION] */
	TextYAlignment: Enum.TextYAlignment;
}

interface ScrollingFrame extends GuiObject {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ScrollingFrame";
	/** The size in pixels of the frame, without the scrollbars.The size in pixels of the frame, without the scrollbars. *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly AbsoluteWindowSize: Vector2;
	/** The "Down" image on the vertical scrollbar. Size of this is always ScrollBarThickness by ScrollBarThickness. This is also used as the "right" image on the horizontal scroll bar. */
	BottomImage: string;
	/** The absolute position the scroll frame is in respect to the canvas size. The minimum this can be set to is (0,0), while the max is the absolute canvas size - AbsoluteWindowSize. */
	CanvasPosition: Vector2;
	/** Determines the size of the area that is scrollable. The UDim2 is calculated using the parent gui's size, similar to the regular Size property on gui objects. */
	CanvasSize: UDim2;
	/** [NO DOCUMENTATION] */
	ElasticBehavior: Enum.ElasticBehavior;
	/** [NO DOCUMENTATION] */
	HorizontalScrollBarInset: Enum.ScrollBarInset;
	/** The "Middle" image on the vertical scrollbar. Size of this can vary in the y direction, but is always set at ScrollBarThickness in x direction. This is also used as the "mid" image on the horizontal scroll bar. */
	MidImage: string;
	/** [NO DOCUMENTATION] */
	ScrollBarImageColor3: Color3;
	/** [NO DOCUMENTATION] */
	ScrollBarImageTransparency: number;
	/** How thick the scroll bar appears. This applies to both the horizontal and vertical scroll bars. Can be set to 0 for no bars render. */
	ScrollBarThickness: number;
	/** [NO DOCUMENTATION] */
	ScrollingDirection: Enum.ScrollingDirection;
	/** Determines whether or not scrolling is allowed on this frame. If turned off, no scroll bars will be rendered. */
	ScrollingEnabled: boolean;
	/** The "Up" image on the vertical scrollbar. Size of this is always ScrollBarThickness by ScrollBarThickness. This is also used as the "left" image on the horizontal scroll bar. */
	TopImage: string;
	/** [NO DOCUMENTATION] */
	VerticalScrollBarInset: Enum.ScrollBarInset;
	/** [NO DOCUMENTATION] */
	VerticalScrollBarPosition: Enum.VerticalScrollBarPosition;
}

interface TextBox extends GuiObject {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TextBox";
	ClearTextOnFocus: boolean;
	CursorPosition: number;
	Font: Enum.Font;
	LineHeight: number;
	MultiLine: boolean;
	PlaceholderColor3: Color3;
	PlaceholderText: string;
	ShowNativeInput: boolean;
	Text: string;
	readonly TextBounds: Vector2;
	TextColor3: Color3;
	readonly TextFits: boolean;
	TextScaled: boolean;
	TextSize: number;
	TextStrokeColor3: Color3;
	TextStrokeTransparency: number;
	TextTransparency: number;
	TextTruncate: Enum.TextTruncate;
	TextWrapped: boolean;
	TextXAlignment: Enum.TextXAlignment;
	TextYAlignment: Enum.TextYAlignment;
	CaptureFocus(): void;
	IsFocused(): boolean;
	ReleaseFocus(submitted?: boolean): void;

	readonly FocusLost: RBXScriptSignal<(enterPressed: boolean, inputThatCausedFocusLoss: InputObject) => void>;
	readonly Focused: RBXScriptSignal<() => void>;
}

interface ViewportFrame extends GuiObject {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ViewportFrame";
	/** Changing this changes the color tint of all objects in the ViewportFrame. */
	Ambient: Color3;
	/** Current Camera of children objectsCurrent Camera of children objects *
	 * Tags: NotReplicated
	 */
	CurrentCamera?: Camera;
	/** The rendered image of the ViewportFrame will be mutiplied by this color */
	ImageColor3: Color3;
	/** A number value that specifies how transparent the rendered image of the ViewportFrame is */
	ImageTransparency: number;
	/** Directional light color for objects in the ViewportFrame. */
	LightColor: Color3;
	/** Light direction. Value will be normalized. All values valid except (0,0,0). */
	LightDirection: Vector3;
}

interface LayerCollector extends GuiBase2d {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "LayerCollector" | "BillboardGui" | "PluginGui" | "ScreenGui" | "SurfaceGui" | "DockWidgetPluginGui" | "QWidgetPluginGui" | "GuiMain";
	/** [NO DOCUMENTATION] */
	Enabled: boolean;
	/** [NO DOCUMENTATION] */
	ResetOnSpawn: boolean;
	/** [NO DOCUMENTATION] */
	ZIndexBehavior: Enum.ZIndexBehavior;
}

interface BillboardGui extends LayerCollector {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BillboardGui";
	/** If true, this GuiObject can fire mouse events and will pass them to any GuiObjects layered underneath, while false will do neither. */
	Active: boolean;
	/** The Object the billboard gui uses as its base to render from.  Currently, the only way to set this property is thru a script, and must exist in the workspace.  This will only render if the object assigned derives from BasePart. */
	Adornee: PVInstance | Attachment | undefined;
	/** If true, billboard gui does not get occluded by 3D objects, but always renders on the screen. */
	AlwaysOnTop: boolean;
	ClipsDescendants: boolean;
	readonly CurrentDistance: number;
	DistanceLowerLimit: number;
	DistanceStep: number;
	DistanceUpperLimit: number;
	/** A Vector3 (x,y,z) defined in studs that will offset the gui from the extents of the 3d object it is rendering from. */
	ExtentsOffset: Vector3;
	ExtentsOffsetWorldSpace: Vector3;
	/** Specifies the amount of influence lighting has on the billboard gui. A value of 0 is unlit, 1 is fully lit. Fractional values blend from unlit to lit. */
	LightInfluence: number;
	MaxDistance: number;
	/** Specifies a Player that the BillboardGui will not render to. */
	PlayerToHideFrom: Player | undefined;
	/** A UDim2 value describing the size of the BillboardGui. More information on UDim2 is available [here](http://wiki.roblox.com/index.php/UDim2). Relative values are defined as one-to-one with studs. */
	Size: UDim2;
	/** A Vector2 (x,y) defined in studs that will offset the gui size from it's current size. */
	SizeOffset: Vector2;
	/** A Vector3 (x,y,z) defined in studs that will offset the gui from the centroid of the 3d object it is rendering from */
	StudsOffset: Vector3;
	StudsOffsetWorldSpace: Vector3;
}

interface PluginGui extends LayerCollector {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PluginGui" | "DockWidgetPluginGui" | "QWidgetPluginGui";
	/** [NO DOCUMENTATION] */
	Title: string;
	/** [NO DOCUMENTATION] */
	BindToClose(callback?: Function): void;
}

interface DockWidgetPluginGui extends PluginGui {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "DockWidgetPluginGui";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly HostWidgetWasRestored: boolean;
}

interface QWidgetPluginGui extends PluginGui {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "QWidgetPluginGui";
}

interface ScreenGui extends LayerCollector {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ScreenGui" | "GuiMain";
	/** [NO DOCUMENTATION] */
	DisplayOrder: number;
	/** [NO DOCUMENTATION] */
	IgnoreGuiInset: boolean;
}

interface GuiMain extends ScreenGui {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "GuiMain";
}

interface SurfaceGui extends LayerCollector {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SurfaceGui";
	/** If true, this GuiObject can fire mouse events and will pass them to any GuiObjects layered underneath, while false will do neither. */
	Active: boolean;
	/** The Object the surface gui uses as its base to render from.  Currently, the only way to set this property is thru a script, and must exist in the workspace.  This will only render if the object assigned derives from BasePart. */
	Adornee: BasePart | undefined;
	AlwaysOnTop: boolean;
	CanvasSize: Vector2;
	ClipsDescendants: boolean;
	Face: Enum.NormalId;
	/** Specifies the amount of influence lighting has on the surface gui. A value of 0 is unlit, 1 is fully lit. Fractional values blend from unlit to lit. */
	LightInfluence: number;
	PixelsPerStud: number;
	SizingMode: Enum.SurfaceGuiSizingMode;
	ToolPunchThroughDistance: number;
	ZOffset: number;
}

interface GuiBase3d extends GuiBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "GuiBase3d" | "FloorWire" | "PVAdornment" | "PartAdornment" | "SelectionLasso" | "HandleAdornment" | "ParabolaAdornment" | "SelectionBox" | "SelectionSphere" | "BoxHandleAdornment" | "ConeHandleAdornment" | "CylinderHandleAdornment" | "ImageHandleAdornment" | "LineHandleAdornment" | "SphereHandleAdornment" | "HandlesBase" | "SurfaceSelection" | "ArcHandles" | "Handles" | "SelectionPartLasso" | "SelectionPointLasso";
	/** [NO DOCUMENTATION] */
	Color3: Color3;
	/** [NO DOCUMENTATION] */
	Transparency: number;
	/** [NO DOCUMENTATION] */
	Visible: boolean;
}

interface FloorWire extends GuiBase3d {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "FloorWire";
	/** Controls how the decals are positioned along the wire. [More info](http://wiki.roblox.com/index.php/CycleOffset) */
	CycleOffset: number;
	/** The object the FloorWire 'emits' from */
	From?: BasePart;
	/** The space between two textures on the wire. Note: studs are relative depending on how far the camera is from the FloorWire. */
	StudsBetweenTextures: number;
	/** The image we use to render the textures that flow from beginning to end of the FloorWire. */
	Texture: string;
	/** The size in studs of the Texture we use to flow from one object to the next. */
	TextureSize: Vector2;
	/** The object the FloorWire 'emits' to */
	To?: BasePart;
	/** The rate of travel that the textures flow along the wire. */
	Velocity: number;
	/** How thick the wire is. */
	WireRadius: number;
}

interface PVAdornment extends GuiBase3d {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PVAdornment" | "HandleAdornment" | "ParabolaAdornment" | "SelectionBox" | "SelectionSphere" | "BoxHandleAdornment" | "ConeHandleAdornment" | "CylinderHandleAdornment" | "ImageHandleAdornment" | "LineHandleAdornment" | "SphereHandleAdornment";
	/** [NO DOCUMENTATION] */
	Adornee?: PVInstance;
}

interface HandleAdornment extends PVAdornment {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "HandleAdornment" | "BoxHandleAdornment" | "ConeHandleAdornment" | "CylinderHandleAdornment" | "ImageHandleAdornment" | "LineHandleAdornment" | "SphereHandleAdornment";
	/** [NO DOCUMENTATION] */
	AlwaysOnTop: boolean;
	/** [NO DOCUMENTATION] */
	CFrame: CFrame;
	/** [NO DOCUMENTATION] */
	SizeRelativeOffset: Vector3;
	/** [NO DOCUMENTATION] */
	ZIndex: number;
	/** [NO DOCUMENTATION] */
	readonly MouseButton1Down: RBXScriptSignal<() => void>;
	/** [NO DOCUMENTATION] */
	readonly MouseButton1Up: RBXScriptSignal<() => void>;
	/** [NO DOCUMENTATION] */
	readonly MouseEnter: RBXScriptSignal<() => void>;
	/** [NO DOCUMENTATION] */
	readonly MouseLeave: RBXScriptSignal<() => void>;
}

interface BoxHandleAdornment extends HandleAdornment {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BoxHandleAdornment";
	/** [NO DOCUMENTATION] */
	Size: Vector3;
}

interface ConeHandleAdornment extends HandleAdornment {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ConeHandleAdornment";
	/** [NO DOCUMENTATION] */
	Height: number;
	/** [NO DOCUMENTATION] */
	Radius: number;
}

interface CylinderHandleAdornment extends HandleAdornment {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CylinderHandleAdornment";
	/** [NO DOCUMENTATION] */
	Height: number;
	/** [NO DOCUMENTATION] */
	Radius: number;
}

interface ImageHandleAdornment extends HandleAdornment {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ImageHandleAdornment";
	/** [NO DOCUMENTATION] */
	Image: string;
	/** [NO DOCUMENTATION] */
	Size: Vector2;
}

interface LineHandleAdornment extends HandleAdornment {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "LineHandleAdornment";
	/** [NO DOCUMENTATION] */
	Length: number;
	/** [NO DOCUMENTATION] */
	Thickness: number;
}

interface SphereHandleAdornment extends HandleAdornment {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SphereHandleAdornment";
	/** [NO DOCUMENTATION] */
	Radius: number;
}

interface ParabolaAdornment extends PVAdornment {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ParabolaAdornment";
}

interface SelectionBox extends PVAdornment {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SelectionBox";
	/** [NO DOCUMENTATION] */
	LineThickness: number;
	/** [NO DOCUMENTATION] */
	SurfaceColor3: Color3;
	/** [NO DOCUMENTATION] */
	SurfaceTransparency: number;
}

interface SelectionSphere extends PVAdornment {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SelectionSphere";
	/** [NO DOCUMENTATION] */
	SurfaceColor3: Color3;
	/** [NO DOCUMENTATION] */
	SurfaceTransparency: number;
}

interface PartAdornment extends GuiBase3d {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PartAdornment" | "HandlesBase" | "SurfaceSelection" | "ArcHandles" | "Handles";
	/** [NO DOCUMENTATION] */
	Adornee?: BasePart;
}

interface HandlesBase extends PartAdornment {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "HandlesBase" | "ArcHandles" | "Handles";
}

interface ArcHandles extends HandlesBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ArcHandles";
	/** [NO DOCUMENTATION] */
	Axes: Axes;
	/** [NO DOCUMENTATION] */
	readonly MouseButton1Down: RBXScriptSignal<(axis: Enum.Axis) => void>;
	/** [NO DOCUMENTATION] */
	readonly MouseButton1Up: RBXScriptSignal<(axis: Enum.Axis) => void>;
	/** [NO DOCUMENTATION] */
	readonly MouseDrag: RBXScriptSignal<(axis: Enum.Axis, relativeAngle: number, deltaRadius: number) => void>;
	/** [NO DOCUMENTATION] */
	readonly MouseEnter: RBXScriptSignal<(axis: Enum.Axis) => void>;
	/** [NO DOCUMENTATION] */
	readonly MouseLeave: RBXScriptSignal<(axis: Enum.Axis) => void>;
}

interface Handles extends HandlesBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Handles";
	/** [NO DOCUMENTATION] */
	Faces: Faces;
	/** [NO DOCUMENTATION] */
	Style: Enum.HandlesStyle;
	/** [NO DOCUMENTATION] */
	readonly MouseButton1Down: RBXScriptSignal<(face: Enum.NormalId) => void>;
	/** [NO DOCUMENTATION] */
	readonly MouseButton1Up: RBXScriptSignal<(face: Enum.NormalId) => void>;
	/** [NO DOCUMENTATION] */
	readonly MouseDrag: RBXScriptSignal<(face: Enum.NormalId, distance: number) => void>;
	/** [NO DOCUMENTATION] */
	readonly MouseEnter: RBXScriptSignal<(face: Enum.NormalId) => void>;
	/** [NO DOCUMENTATION] */
	readonly MouseLeave: RBXScriptSignal<(face: Enum.NormalId) => void>;
}

interface SurfaceSelection extends PartAdornment {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SurfaceSelection";
	/** [NO DOCUMENTATION] */
	TargetSurface: Enum.NormalId;
}

interface SelectionLasso extends GuiBase3d {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SelectionLasso" | "SelectionPartLasso" | "SelectionPointLasso";
	/** [NO DOCUMENTATION] */
	Humanoid?: Humanoid;
}

interface SelectionPartLasso extends SelectionLasso {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SelectionPartLasso";
	/** [NO DOCUMENTATION] */
	Part?: BasePart;
}

interface SelectionPointLasso extends SelectionLasso {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SelectionPointLasso";
	/** [NO DOCUMENTATION] */
	Point: Vector3;
}

/** @rbxts client */
interface GuiService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "GuiService";
	AutoSelectGuiEnabled: boolean;
	CoreGuiNavigationEnabled: boolean;
	GuiNavigationEnabled: boolean;
	readonly MenuIsOpen: boolean;
	SelectedObject?: GuiObject;

	AddSelectionParent(selectionName: string, selectionParent: Instance): void;

	AddSelectionTuple(selectionName: string, selections: Array<any>): void;
	CloseInspectMenu(): void;
	GetEmotesMenuOpen(): boolean;
	/** Returns a Tuple containing two Vector2 values representing the offset of user GUIs in pixels from the top right corner of the screen and the bottom right corner of the screen respectively. */
	GetGuiInset(): LuaTuple<[Vector2, Vector2]>;
	GetInspectMenuEnabled(): boolean;
	InspectPlayerFromHumanoidDescription(humanoidDescription: Instance, name: string): void;
	InspectPlayerFromUserId(userId: number): void;
	IsTenFootInterface(): boolean;
	RemoveSelectionGroup(selectionName: string): void;
	SetEmotesMenuOpen(isOpen: boolean): void;
	SetInspectMenuEnabled(enabled: boolean): void;
	readonly MenuClosed: RBXScriptSignal<() => void>;
	readonly MenuOpened: RBXScriptSignal<() => void>;
}

interface GuidRegistryService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "GuidRegistryService";
}

interface HapticService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "HapticService";
	/** [NO DOCUMENTATION] */
	GetMotor(inputType: CastsToEnum<Enum.UserInputType>, vibrationMotor: CastsToEnum<Enum.VibrationMotor>): unknown;
	/** [NO DOCUMENTATION] */
	IsMotorSupported(inputType: CastsToEnum<Enum.UserInputType>, vibrationMotor: CastsToEnum<Enum.VibrationMotor>): boolean;
	/** [NO DOCUMENTATION] */
	IsVibrationSupported(inputType: CastsToEnum<Enum.UserInputType>): boolean;
	/** [NO DOCUMENTATION] */
	SetMotor(inputType: CastsToEnum<Enum.UserInputType>, vibrationMotor: CastsToEnum<Enum.VibrationMotor>, vibrationValues: Array<any>): void;
}

interface Hopper extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Hopper";
}

interface HttpRbxApiService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "HttpRbxApiService";
}

interface HttpRequest extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "HttpRequest";
}

interface HttpService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "HttpService";
	GenerateGUID(wrapInCurlyBraces?: boolean): string;
	JSONDecode(input: string): unknown;
	JSONEncode(input?: any): string;
	UrlEncode(input: string): string;
	/** @rbxts server */
	GetAsync(url: string, nocache?: boolean, headers?: HttpHeaders): string;
	/** @rbxts server */
	PostAsync(
		url: string,
		data: string,
		content_type?: CastsToEnum<Enum.HttpContentType>,
		compress?: boolean,
		headers?: HttpHeaders,
	): string;
	/** @rbxts server */
	RequestAsync(requestOptions: RequestAsyncRequest): RequestAsyncResponse;
}

interface Humanoid extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Humanoid";
	AutoJumpEnabled: boolean;
	AutoRotate: boolean;
	AutomaticScalingEnabled: boolean;
	BreakJointsOnDeath: boolean;
	CameraOffset: Vector3;
	/** An emum that selects the collision type for R15 and Rthro characters. InnerBox is classic style collisions for all characters, OuterBox is dynamically sized collisions based on Mesh size. */
	readonly CollisionType: Enum.HumanoidCollisionType;
	DisplayDistanceType: Enum.HumanoidDisplayDistanceType;
	readonly FloorMaterial: Enum.Material;
	/** How many hit points the Humanoid has.  When this number reaches 0 or goes below 0, the Humanoid's character falls apart and will respawn. */
	Health: number;
	HealthDisplayDistance: number;
	HealthDisplayType: Enum.HumanoidHealthDisplayType;
	HipHeight: number;
	Jump: boolean;
	JumpHeight: number;
	JumpPower: number;
	/** The maximum number of hit points a Humanoid's health can reach.  If the Humanoid's health is set over this amount, the health gets set to this value. */
	MaxHealth: number;
	MaxSlopeAngle: number;
	readonly MoveDirection: Vector3;
	NameDisplayDistance: number;
	/** Sets how to display other humanoid names to this humanoid's player. [More info](http://wiki.roblox.com/index.php/NameOcclusion) */
	NameOcclusion: Enum.NameOcclusion;
	PlatformStand: boolean;
	RigType: Enum.HumanoidRigType;
	readonly RootPart?: BasePart;
	readonly SeatPart?: BasePart;
	Sit: boolean;
	/** The location that the Humanoid is trying to walk to. */
	TargetPoint: Vector3;
	UseJumpPower: boolean;
	WalkSpeed: number;
	WalkToPart?: BasePart;
	WalkToPoint: Vector3;

	AddAccessory(accessory: Accessory): void;
	BuildRigFromAttachments(): void;
	ChangeState(state?: CastsToEnum<Enum.HumanoidStateType>): void;
	/** Takes a specified tool and equips it to the Humanoid's Character.  Tool argument should be of type 'Tool'. */
	EquipTool(tool: Tool | Flag): void;

	GetAccessories(): Array<Accessory>;

	GetAppliedDescription(): HumanoidDescription;
	/** Returns a Enum.BodyPartR15 given a body part in the Humanoid's Character. */
	GetBodyPartR15(part: BasePart): Enum.BodyPartR15;

	GetLimb(part: BasePart): Enum.Limb;

	GetPlayingAnimationTracks(): Array<AnimationTrack>;
	GetState(): Enum.HumanoidStateType;
	GetStateEnabled(state: CastsToEnum<Enum.HumanoidStateType>): boolean;

	LoadAnimation(animation: Animation): AnimationTrack;
	Move(moveDirection: Vector3, relativeToCamera?: boolean): void;
	/** Attempts to move the Humanoid and it's associated character to 'part'. 'location' is used as an offset from part's origin. */
	MoveTo(location: Vector3, part?: BasePart): void;
	RemoveAccessories(): void;
	/** Replaces the desired bodypart on the Humanoid's Character using a specified Enum.BodyPartR15 and BasePart. Returns a success boolean. */
	ReplaceBodyPartR15(bodyPart: Enum.BodyPartR15, part: BasePart): boolean;
	SetStateEnabled(state: CastsToEnum<Enum.HumanoidStateType>, enabled: boolean): void;
	/** Decreases health by the amount.  Use this instead of changing health directly to make sure weapons are filtered for things such as ForceField(s). */
	TakeDamage(amount: number): void;
	/** Takes any active gear/tools that the Humanoid is using and puts them into the backpack.  This function only works on Humanoids with a corresponding Player. */
	UnequipTools(): void;

	ApplyDescription(humanoidDescription: HumanoidDescription): void;
	PlayEmote(emoteName: string): boolean;

	readonly AnimationPlayed: RBXScriptSignal<(animationTrack: AnimationTrack) => void>;
	readonly Climbing: RBXScriptSignal<(speed: number) => void>;
	readonly Died: RBXScriptSignal<() => void>;
	readonly FallingDown: RBXScriptSignal<(active: boolean) => void>;
	readonly FreeFalling: RBXScriptSignal<(active: boolean) => void>;
	readonly GettingUp: RBXScriptSignal<(active: boolean) => void>;
	readonly HealthChanged: RBXScriptSignal<(health: number) => void>;
	readonly Jumping: RBXScriptSignal<(active: boolean) => void>;
	readonly MoveToFinished: RBXScriptSignal<(reached: boolean) => void>;
	readonly PlatformStanding: RBXScriptSignal<(active: boolean) => void>;
	readonly Ragdoll: RBXScriptSignal<(active: boolean) => void>;
	readonly Running: RBXScriptSignal<(speed: number) => void>;

	readonly Seated: RBXScriptSignal<(active: boolean, currentSeatPart: Seat | VehicleSeat) => void>;
	readonly StateChanged: RBXScriptSignal<(oldValue: Enum.HumanoidStateType, newValue: Enum.HumanoidStateType) => void>;
	readonly StateEnabledChanged: RBXScriptSignal<(state: Enum.HumanoidStateType, isEnabled: boolean) => void>;
	readonly Strafing: RBXScriptSignal<(active: boolean) => void>;
	readonly Swimming: RBXScriptSignal<(speed: number) => void>;

	readonly Touched: RBXScriptSignal<(touchingPart: BasePart, humanoidPart: BasePart) => void>;
}

/** #### Related methods:
 * - Humanoid.ApplyDescription()
 * - Humanoid.GetAppliedDescription()
 * - Player.LoadCharacterWithHumanoidDescription()
 * - Players.GetHumanoidDescriptionFromOutfitId()
 * - Players.GetHumanoidDescriptionFromUserId()
 */
interface HumanoidDescription extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "HumanoidDescription";
	BackAccessory: string;
	BodyTypeScale: number;
	ClimbAnimation: number;
	DepthScale: number;
	Face: number;
	FaceAccessory: string;
	FallAnimation: number;
	FrontAccessory: string;
	GraphicTShirt: number;
	HairAccessory: string;
	HatAccessory: string;
	Head: number;
	HeadColor: Color3;
	HeadScale: number;
	HeightScale: number;
	IdleAnimation: number;
	JumpAnimation: number;
	LeftArm: number;
	LeftArmColor: Color3;
	LeftLeg: number;
	LeftLegColor: Color3;
	NeckAccessory: string;
	Pants: number;
	ProportionScale: number;
	RightArm: number;
	RightArmColor: Color3;
	RightLeg: number;
	RightLegColor: Color3;
	RunAnimation: number;
	Shirt: number;
	ShouldersAccessory: string;
	SwimAnimation: number;
	Torso: number;
	TorsoColor: Color3;
	WaistAccessory: string;
	WalkAnimation: number;
	WidthScale: number;
	AddEmote(name: string, assetId: number): void;
	GetEmotes(): object;
	GetEquippedEmotes(): unknown;
	RemoveEmote(name: string): void;
	SetEmotes(emotes: object): void;
	SetEquippedEmotes(equippedEmotes: Array<any>): void;
	readonly EmotesChanged: RBXScriptSignal<(newEmotes: object) => void>;
	readonly EquippedEmotesChanged: RBXScriptSignal<(newEquippedEmotes: Array<any>) => void>;
}

interface InputObject extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "InputObject";
	/** [NO DOCUMENTATION] */
	Delta: Vector3;
	/** An enum that describes what kind of input is being pressed. For types of input like Keyboard, this describes what key was pressed. For input like mousebutton, this provides no additional information. */
	KeyCode: Enum.KeyCode;
	/** A Vector3 value that describes a positional value of this input. For mouse and touch input, this is the screen position of the mouse/touch, described in the x and y components. For mouse wheel input, the z component describes whether the wheel was moved forward or backward. */
	Position: Vector3;
	/** An enum that describes what state of a particular input (touch began, touch moved, touch ended, etc.). See Enum.UserInputState for more info. */
	UserInputState: Enum.UserInputState;
	/** An enum that describes what kind of input this object is describing (mousebutton, touch, etc.).  See Enum.UserInputType for more info. */
	UserInputType: Enum.UserInputType;
}

interface InsertService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "InsertService";
	/** Returns a table containing a list of the various setIds that are ROBLOX approved. [More info on sets](http://wiki.roblox.com/index.php/Sets) */
	GetBaseSets(): Array<SetInfo>;
	/** Returns a table for the assets stored in the category.  A category is an setId from www.roblox.com that links to a set.  [More info on table format](http://wiki.roblox.com/index.php?title=API:Class/InsertService/GetCollection). [More info on sets](http://wiki.roblox.com/index.php/Sets) */
	GetCollection(categoryId: number): Array<CollectionInfo>;

	GetFreeDecals(searchText: string, pageNum: number): [Array<FreeSearchResult>];

	GetFreeModels(searchText: string, pageNum: number): [Array<FreeSearchResult>];
	GetLatestAssetVersionAsync(assetId: number): number;
	/** Returns a table containing a list of the various setIds that correspond to argument 'userId'. [More info on sets](http://wiki.roblox.com/index.php/Sets) */
	GetUserSets(userId: number): Array<SetInfo>;
	/** Returns a Model containing the Instance that resides at AssetId on the web. This call will also yield the script until the model is returned. Script execution can still continue, however, if you use a [coroutine](http://wiki.roblox.com/index.php?title=Coroutine). */
	LoadAsset(assetId: number): Model;
	/** Similar to LoadAsset, but instead an AssetVersionId is passed in, which refers to a particular version of the asset which is not neccessarily the latest version. */
	LoadAssetVersion(assetVersionId: number): Model;
}

interface JointInstance extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "JointInstance" | "DynamicRotate" | "Glue" | "ManualSurfaceJointInstance" | "Motor" | "Rotate" | "Snap" | "VelocityMotor" | "Weld" | "RotateP" | "RotateV" | "ManualGlue" | "ManualWeld" | "Motor6D";
	/** Read-only boolean, true if the joint is active in world. Rigid joints may be inactive if they are redundant or form cycles. */
	readonly Active: boolean;
	C0: CFrame;
	C1: CFrame;

	Part0: BasePart | undefined;

	Part1: BasePart | undefined;
}

interface DynamicRotate extends JointInstance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "DynamicRotate" | "RotateP" | "RotateV";
	/** [NO DOCUMENTATION] */
	BaseAngle: number;
}

interface RotateP extends DynamicRotate {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RotateP";
}

interface RotateV extends DynamicRotate {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RotateV";
}

interface Glue extends JointInstance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Glue";
	/** [NO DOCUMENTATION] */
	F0: Vector3;
	/** [NO DOCUMENTATION] */
	F1: Vector3;
	/** [NO DOCUMENTATION] */
	F2: Vector3;
	/** [NO DOCUMENTATION] */
	F3: Vector3;
}

interface ManualSurfaceJointInstance extends JointInstance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ManualSurfaceJointInstance" | "ManualGlue" | "ManualWeld";
}

interface ManualGlue extends ManualSurfaceJointInstance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ManualGlue";
}

interface ManualWeld extends ManualSurfaceJointInstance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ManualWeld";
}

interface Motor extends JointInstance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Motor" | "Motor6D";
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	CurrentAngle: number;
	/** [NO DOCUMENTATION] */
	DesiredAngle: number;
	/** [NO DOCUMENTATION] */
	MaxVelocity: number;
	/** [NO DOCUMENTATION] */
	SetDesiredAngle(value: number): void;
}

interface Motor6D extends Motor {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Motor6D";
	/** [NO DOCUMENTATION] *
	 * Tags: Hidden, NotReplicated
	 */
	Transform: CFrame;
}

interface Rotate extends JointInstance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Rotate";
}

interface Snap extends JointInstance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Snap";
}

interface VelocityMotor extends JointInstance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "VelocityMotor";
	/** [NO DOCUMENTATION] */
	CurrentAngle: number;
	/** [NO DOCUMENTATION] */
	DesiredAngle: number;
	/** [NO DOCUMENTATION] */
	Hole?: Hole;
	/** [NO DOCUMENTATION] */
	MaxVelocity: number;
}

interface Weld extends JointInstance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Weld";
}

interface JointsService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "JointsService";
	ClearJoinAfterMoveJoints(): void;
	CreateJoinAfterMoveJoints(): void;

	SetJoinAfterMoveInstance(joinInstance: PVInstance): void;

	SetJoinAfterMoveTarget(joinTarget: PVInstance): void;
	ShowPermissibleJoints(): void;
}

interface KeyboardService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "KeyboardService";
}

interface Keyframe extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Keyframe";
	Time: number;

	AddMarker(marker: KeyframeMarker): void;

	AddPose(pose: Pose): void;
	GetMarkers(): Array<Instance>;

	GetPoses(): Array<Pose>;

	RemoveMarker(marker: KeyframeMarker): void;

	RemovePose(pose: Pose): void;
}

interface KeyframeMarker extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "KeyframeMarker";
	/** [NO DOCUMENTATION] */
	Value: string;
}

interface KeyframeSequence extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "KeyframeSequence";
	Loop: boolean;
	Priority: Enum.AnimationPriority;

	AddKeyframe(keyframe: Keyframe): void;

	GetKeyframes(): Array<Keyframe>;

	RemoveKeyframe(keyframe: Keyframe): void;
}

interface KeyframeSequenceProvider extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "KeyframeSequenceProvider";

	RegisterActiveKeyframeSequence(keyframeSequence: KeyframeSequence): string;

	RegisterKeyframeSequence(keyframeSequence: KeyframeSequence): string;

	GetAnimations(userId: number): InventoryPages;

	GetKeyframeSequenceAsync(assetId: string): KeyframeSequence;
}

interface Light extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Light" | "PointLight" | "SpotLight" | "SurfaceLight";
	/** [NO DOCUMENTATION] */
	Brightness: number;
	/** [NO DOCUMENTATION] */
	Color: Color3;
	/** [NO DOCUMENTATION] */
	Enabled: boolean;
	/** [NO DOCUMENTATION] */
	Shadows: boolean;
}

interface PointLight extends Light {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PointLight";
	/** [NO DOCUMENTATION] */
	Range: number;
}

interface SpotLight extends Light {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SpotLight";
	/** [NO DOCUMENTATION] */
	Angle: number;
	/** [NO DOCUMENTATION] */
	Face: Enum.NormalId;
	/** [NO DOCUMENTATION] */
	Range: number;
}

interface SurfaceLight extends Light {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SurfaceLight";
	/** [NO DOCUMENTATION] */
	Angle: number;
	/** [NO DOCUMENTATION] */
	Face: Enum.NormalId;
	/** [NO DOCUMENTATION] */
	Range: number;
}

interface Lighting extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Lighting";
	/** The hue of the global lighting.  Changing this changes the color tint of all objects in the Workspace. */
	Ambient: Color3;
	/** How much global light each Part in the Workspace receives. Standard range is 0 to 2 (0 being little light), but can be increased all the way to 10 (colors start to be appear very different at this value). */
	Brightness: number;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	ClockTime: number;
	/** The hue of global lighting on the bottom surfaces of an object. */
	ColorShift_Bottom: Color3;
	/** The hue of global lighting on the top surfaces of an object. */
	ColorShift_Top: Color3;
	/** Exposure compensation amount. Applies a bias to the exposure level prior to the tonemap step. +1 indicates twice as much exposure and -1 means half as much exposure. */
	ExposureCompensation: number;
	/** A Color3 value that changes the hue of distance fog. */
	FogColor: Color3;
	/** The distance at which fog completely blocks your vision. This distance is relative to the camera position. Units are in studs */
	FogEnd: number;
	/** The distance at which the fog gradient begins. This distance is relative to the camera position. Units are in studs. */
	FogStart: number;
	/** The latitude position the level is placed at.  This affects sun position. [More info](http://wiki.roblox.com/index.php/GeographicLatitude) */
	GeographicLatitude: number;
	/** Flag enabling shadows from sun and moon in the place */
	GlobalShadows: boolean;
	/** Effective ambient value for outdoors, effectively shadow color outdoors (requires GlobalShadows enabled) */
	OutdoorAmbient: Color3;
	/** Flag enabling or disabling outlines on parts and terrain */
	Outlines: boolean;
	/** This property controls how blurry the shadows are. */
	ShadowSoftness: number;
	/** A string that represent the current time of day. Time is in 24-hour clock format "XX::YY:ZZ", where X is hour, Y is minute, and Z is seconds. */
	TimeOfDay: string;
	/** The number of minutes that the current time is past midnight.  If currently at midnight, returns 0.  Will return decimal values if not at an exact minute. */
	GetMinutesAfterMidnight(): number;
	/** Returns the lookVector (Vector3) of the moon. If this lookVector was used in a CFrame, the Part would face the moon. */
	GetMoonDirection(): Vector3;
	/** Currently always returns 0.75. MoonPhase cannot be edited. */
	GetMoonPhase(): number;
	/** Returns the lookVector (Vector3) of the sun. If this lookVector was used in a CFrame, the Part would face the sun. */
	GetSunDirection(): Vector3;
	/** Sets the time to be a certain number of minutes after midnight.  This works with integer and decimal values. */
	SetMinutesAfterMidnight(minutes: number): void;
	/** Fired whenever a property of Lighting is changed, or a skybox is added or removed. Skyboxes are of type 'Sky' and should be parented directly to lighting. */
	readonly LightingChanged: RBXScriptSignal<(skyboxChanged: boolean) => void>;
}

interface LocalStorageService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "LocalStorageService" | "AppStorageService" | "UserStorageService";
}

interface AppStorageService extends LocalStorageService {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "AppStorageService";
}

interface UserStorageService extends LocalStorageService {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UserStorageService";
}

interface LocalizationService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "LocalizationService";
	readonly RobloxLocaleId: string;
	readonly SystemLocaleId: string;
	GetCorescriptLocalizations(): Array<Instance>;
	GetTableEntries(instance?: Instance): unknown;

	GetTranslatorForPlayer(player: Player): Translator;

	GetTranslatorForLocaleAsync(locale: string): Translator;

	GetTranslatorForPlayerAsync(player: Player): Translator;
}

interface LocalizationTable extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "LocalizationTable";
	SourceLocaleId: string;

	GetEntries(): Array<LocalizationEntry>;

	GetTranslator(localeId: string): Translator;
	RemoveEntry(key: string, source: string, context: string): void;
	RemoveEntryValue(key: string, source: string, context: string, localeId: string): void;
	RemoveTargetLocale(localeId: string): void;
	SetEntries(entries?: any): void;
	SetEntryContext(key: string, source: string, context: string, newContext: string): void;
	SetEntryExample(key: string, source: string, context: string, example: string): void;
	SetEntryKey(key: string, source: string, context: string, newKey: string): void;
	SetEntrySource(key: string, source: string, context: string, newSource: string): void;
	SetEntryValue(key: string, source: string, context: string, localeId: string, text: string): void;
}

interface LogService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "LogService";

	GetLogHistory(): Array<LogInfo>;
	readonly MessageOut: RBXScriptSignal<(message: string, messageType: Enum.MessageType) => void>;
}

interface LoginService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "LoginService";
}

interface LuaSettings extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "LuaSettings";
	/** [NO DOCUMENTATION] */
	AreScriptStartsReported: boolean;
	/** [NO DOCUMENTATION] */
	DefaultWaitTime: number;
	/** [NO DOCUMENTATION] */
	GcFrequency: number;
	/** [NO DOCUMENTATION] */
	GcLimit: number;
	/** [NO DOCUMENTATION] */
	GcPause: number;
	/** [NO DOCUMENTATION] */
	GcStepMul: number;
	/** [NO DOCUMENTATION] */
	WaitingThreadsBudget: number;
}

interface LuaSourceContainer extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "LuaSourceContainer" | "BaseScript" | "ModuleScript" | "CoreScript" | "Script" | "LocalScript";
}

interface BaseScript extends LuaSourceContainer {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BaseScript" | "CoreScript" | "Script" | "LocalScript";
	/** [NO DOCUMENTATION] */
	Disabled: boolean;
	/** [NO DOCUMENTATION] */
	LinkedSource: string;
}

interface CoreScript extends BaseScript {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CoreScript";
}

interface Script extends BaseScript {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Script" | "LocalScript";
}

interface LocalScript extends Script {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "LocalScript";
}

interface ModuleScript extends LuaSourceContainer {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ModuleScript";
	/** [NO DOCUMENTATION] */
	LinkedSource: string;
}

interface LuaWebService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "LuaWebService";
}

interface MarketplaceService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "MarketplaceService";

	PromptGamePassPurchase(player: Player, gamePassId: number): void;

	PromptProductPurchase(
		player: Player,
		productId: number,
		equipIfPurchased?: boolean,
		currencyType?: CastsToEnum<Enum.CurrencyType>,
	): void;
	/** Will prompt 'player' to purchase the item associated with 'assetId'.  'equipIfPurchased' is an optional argument that will give the item to the player immediately if they buy it (only applies to gear).  'currencyType' is also optional and will attempt to prompt the user with a specified currency if the product can be purchased with this currency, otherwise we use the default currency of the product. */
	PromptPurchase(
		player: Player,
		assetId: number,
		equipIfPurchased?: boolean,
		currencyType?: CastsToEnum<Enum.CurrencyType>,
	): void;

	GetDeveloperProductsAsync(): Pages;
	/** Takes one argument "assetId" which should be a number of an asset on www.roblox.com.  Returns a table containing the product information (if this process fails, returns an empty table). */
	GetProductInfo(assetId: number, infoType: CastsToEnum<Enum.InfoType.Asset>): AssetProductInfo;
	GetProductInfo(assetId: number, infoType: CastsToEnum<Enum.InfoType.Product>): DeveloperProductInfo;
	GetProductInfo(assetId: number, infoType: CastsToEnum<Enum.InfoType.GamePass>): AssetProductInfo;
	/** Checks to see if 'Player' owns the product associated with 'assetId'. Returns true if the player owns it, false otherwise. This call will produce a warning if called on a guest player. */
	PlayerOwnsAsset(player: Player, assetId: number): boolean;
	UserOwnsGamePassAsync(userId: number, gamePassId: number): boolean;

	readonly PromptGamePassPurchaseFinished: RBXScriptSignal<
		(player: Player, gamePassId: number, wasPurchased: boolean) => void
	>;
	/** Fired when a 'player' dismisses a purchase dialog for 'assetId'.  If the player purchased the item 'isPurchased' will be true, otherwise it will be false. This call will produce a warning if called on a guest player. */
	readonly PromptPurchaseFinished: RBXScriptSignal<(player: Player, assetId: number, isPurchased: boolean) => void>;
	/** Callback that is executed for pending Developer Product receipts.

            If this function does not return Enum.ProductPurchaseDecision.PurchaseGranted, then you will not be granted the money for the purchase!

            The callback will be invoked with a table, containing the following informational fields:
            PlayerId - the id of the player making the purchase.
            PlaceIdWherePurchased - the specific place where the purchase was made.
            PurchaseId - a unique identifier for the purchase, should be used to prevent granting an item multiple times for one purchase.
            ProductId - the id of the purchased product.
            CurrencyType - the type of currency used (Tix, Robux).
            CurrencySpent - the amount of currency spent on the product for this purchase.
             */
	ProcessReceipt: (receiptInfo: ReceiptInfo) => Enum.ProductPurchaseDecision;
}

interface Message extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Message" | "Hint";
	/** [NO DOCUMENTATION] */
	Text: string;
}

interface Hint extends Message {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Hint";
}

/** @rbxts server */
interface MessagingService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "MessagingService";
	PublishAsync(topic: string, message?: any): void;

	SubscribeAsync(topic: string, callback: (Data: any, Sent: number) => void): RBXScriptConnection;
}

interface Mouse extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Mouse" | "PlayerMouse" | "PluginMouse";
	/** The CoordinateFrame of where the Mouse ray is currently hitting a 3D object in the Workspace.  If the mouse is not over any 3D objects in the Workspace, this property is nil.The CoordinateFrame of where the Mouse ray is currently hitting a 3D object in the Workspace.  If the mouse is not over any 3D objects in the Workspace, this property is nil. *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Hit: CFrame;
	/** The current Texture of the Mouse Icon. Stored as a string, for more information on how to format the string [go here](http://wiki.roblox.com/index.php/Content) */
	Icon: string;
	/** The CoordinateFrame of where the Mouse is when the mouse is not clicking.The CoordinateFrame of where the Mouse is when the mouse is not clicking. *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Origin: CFrame;
	/** The Part the mouse is currently over. If the mouse is not currently over any object (on the skybox, for example) this property is nil.The Part the mouse is currently over. If the mouse is not currently over any object (on the skybox, for example) this property is nil. *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Target?: BasePart;
	/** A Part or Model that the Mouse will ignore when trying to find the Target, TargetSurface and Hit. */
	TargetFilter?: Instance;
	/** The NormalId (Top, Left, Down, etc.) of the face of the part the Mouse is currently over.The NormalId (Top, Left, Down, etc.) of the face of the part the Mouse is currently over. *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly TargetSurface: Enum.NormalId;
	/** The Unit Ray from where the mouse is (Origin) to the current Mouse.Target.The Unit Ray from where the mouse is (Origin) to the current Mouse.Target. *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly UnitRay: Ray;
	/** The viewport's (game window) width in pixels.The viewport's (game window) width in pixels. *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly ViewSizeX: number;
	/** The viewport's (game window) height in pixels.The viewport's (game window) height in pixels. *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly ViewSizeY: number;
	/** The absolute pixel position of the Mouse along the x-axis of the viewport (game window). Values start at 0 on the left hand side of the screen and increase to the right.The absolute pixel position of the Mouse along the x-axis of the viewport (game window). Values start at 0 on the left hand side of the screen and increase to the right. *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly X: number;
	/** The absolute pixel position of the Mouse along the y-axis of the viewport (game window). Values start at 0 on the top of the screen and increase to the bottom.The absolute pixel position of the Mouse along the y-axis of the viewport (game window). Values start at 0 on the top of the screen and increase to the bottom. *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Y: number;
	/** Fired when the first button (usually the left, but could be another) on the mouse is depressed. */
	readonly Button1Down: RBXScriptSignal<() => void>;
	/** Fired when the first button (usually the left, but could be another) on the mouse is release. */
	readonly Button1Up: RBXScriptSignal<() => void>;
	/** This event is currently non-operational. */
	readonly Button2Down: RBXScriptSignal<() => void>;
	/** This event is currently non-operational. */
	readonly Button2Up: RBXScriptSignal<() => void>;
	/** Fired constantly when the mouse is not firing any other event (i.e. the mouse isn't moving, nor any buttons being pressed or depressed). */
	readonly Idle: RBXScriptSignal<() => void>;
	/** Fired when the mouse X or Y member changes. */
	readonly Move: RBXScriptSignal<() => void>;
	/** This event is currently non-operational. */
	readonly WheelBackward: RBXScriptSignal<() => void>;
	/** This event is currently non-operational. */
	readonly WheelForward: RBXScriptSignal<() => void>;
}

interface PlayerMouse extends Mouse {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PlayerMouse";
}

interface PluginMouse extends Mouse {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PluginMouse";
}

interface MouseService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "MouseService";
}

interface NetworkMarker extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "NetworkMarker";
	/** [NO DOCUMENTATION] */
	readonly Received: RBXScriptSignal<() => void>;
}

interface NetworkPeer extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "NetworkPeer" | "NetworkClient" | "NetworkServer";
}

interface NetworkClient extends NetworkPeer {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "NetworkClient";
	Ticket: string;

	readonly ConnectionAccepted: RBXScriptSignal<(peer: string, replicator: ClientReplicator) => void>;
	readonly ConnectionFailed: RBXScriptSignal<(peer: string, code: number, reason: string) => void>;
	readonly ConnectionRejected: RBXScriptSignal<(peer: string) => void>;
}

interface NetworkServer extends NetworkPeer {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "NetworkServer";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Port: number;
}

interface NetworkReplicator extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "NetworkReplicator" | "ClientReplicator" | "ServerReplicator";

	GetPlayer(): Player;
}

interface ClientReplicator extends NetworkReplicator {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ClientReplicator";
}

interface ServerReplicator extends NetworkReplicator {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ServerReplicator";
}

interface NetworkSettings extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "NetworkSettings";
	/** [NO DOCUMENTATION] */
	ArePhysicsRejectionsReported: boolean;
	/** [NO DOCUMENTATION] */
	ClientPhysicsSendRate: number;
	/** [NO DOCUMENTATION] */
	DataGCRate: number;
	/** [NO DOCUMENTATION] */
	DataMtuAdjust: number;
	/** [NO DOCUMENTATION] *
	 * Tags: Hidden, NotReplicated
	 */
	DataSendPriority: Enum.PacketPriority;
	/** [NO DOCUMENTATION] */
	DataSendRate: number;
	/** [NO DOCUMENTATION] */
	IncommingReplicationLag: number;
	/** [NO DOCUMENTATION] */
	IsQueueErrorComputed: boolean;
	/** [NO DOCUMENTATION] */
	NetworkOwnerRate: number;
	/** [NO DOCUMENTATION] */
	PhysicsMtuAdjust: number;
	/** [NO DOCUMENTATION] *
	 * Tags: Hidden, NotReplicated
	 */
	PhysicsSendPriority: Enum.PacketPriority;
	/** [NO DOCUMENTATION] */
	PhysicsSendRate: number;
	/** [NO DOCUMENTATION] */
	PreferredClientPort: number;
	/** [NO DOCUMENTATION] */
	PrintBits: boolean;
	/** [NO DOCUMENTATION] */
	PrintEvents: boolean;
	/** [NO DOCUMENTATION] */
	PrintFilters: boolean;
	/** [NO DOCUMENTATION] */
	PrintInstances: boolean;
	/** [NO DOCUMENTATION] */
	PrintPhysicsErrors: boolean;
	/** [NO DOCUMENTATION] */
	PrintProperties: boolean;
	/** [NO DOCUMENTATION] */
	PrintSplitMessage: boolean;
	/** [NO DOCUMENTATION] */
	PrintStreamInstanceQuota: boolean;
	/** [NO DOCUMENTATION] */
	PrintTouches: boolean;
	/** [NO DOCUMENTATION] */
	ProxyEnabled: boolean;
	/** [NO DOCUMENTATION] */
	ProxyURL: string;
	/** [NO DOCUMENTATION] */
	ReceiveRate: number;
	/** [NO DOCUMENTATION] */
	RenderStreamedRegions: boolean;
	/** [NO DOCUMENTATION] */
	ShowActiveAnimationAsset: boolean;
	/** [NO DOCUMENTATION] */
	TouchSendRate: number;
	/** [NO DOCUMENTATION] */
	TrackDataTypes: boolean;
	/** [NO DOCUMENTATION] */
	TrackPhysicsDetails: boolean;
	/** [NO DOCUMENTATION] */
	UsePhysicsPacketCache: boolean;
}

interface NoCollisionConstraint extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "NoCollisionConstraint";
	/** If true Part0 and Part1 will not collide, if false the parts will collide. */
	Enabled: boolean;
	/** [NO DOCUMENTATION] */
	Part0?: BasePart;
	/** [NO DOCUMENTATION] */
	Part1?: BasePart;
}

interface NotificationService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "NotificationService";
}

interface PVInstance extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PVInstance" | "BasePart" | "Model" | "CornerWedgePart" | "FormFactorPart" | "Terrain" | "TriangleMeshPart" | "TrussPart" | "VehicleSeat" | "Part" | "WedgePart" | "FlagStand" | "Platform" | "Seat" | "SkateboardPlatform" | "SpawnLocation" | "MeshPart" | "PartOperation" | "NegateOperation" | "UnionOperation" | "Status" | "Workspace";
}

interface BasePart extends PVInstance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BasePart" | "CornerWedgePart" | "FormFactorPart" | "Terrain" | "TriangleMeshPart" | "TrussPart" | "VehicleSeat" | "Part" | "WedgePart" | "FlagStand" | "Platform" | "Seat" | "SkateboardPlatform" | "SpawnLocation" | "MeshPart" | "PartOperation" | "NegateOperation" | "UnionOperation";
	/** Determines whether or not physics acts upon the Part.  If true, part stays 'Anchored' in space, not moving regardless of any collision/forces acting upon it.  If false, physics works normally on the part. */
	Anchored: boolean;
	BackParamA: number;
	BackParamB: number;
	BackSurface: Enum.SurfaceType;
	BackSurfaceInput: Enum.InputType;
	BottomParamA: number;
	BottomParamB: number;
	BottomSurface: Enum.SurfaceType;
	BottomSurfaceInput: Enum.InputType;
	BrickColor: BrickColor;
	/** Contains information regarding the Part's position and a matrix that defines the Part's rotation.  Can read/write. [More info](http://wiki.roblox.com/index.php/Cframe) */
	CFrame: CFrame;
	/** Determines whether physical interactions with other Parts are respected.  If true, will collide and react with physics to other Parts.  If false, other parts will pass thru instead of colliding */
	CanCollide: boolean;
	/** Determines whether this Part casts a shadow. */
	CastShadow: boolean;
	readonly CenterOfMass: Vector3;
	CollisionGroupId: number;
	/** Color3 of the part. */
	Color: Color3;
	CustomPhysicalProperties: PhysicalProperties;
	FrontParamA: number;
	FrontParamB: number;
	FrontSurface: Enum.SurfaceType;
	FrontSurfaceInput: Enum.InputType;
	LeftParamA: number;
	LeftParamB: number;
	LeftSurface: Enum.SurfaceType;
	LeftSurfaceInput: Enum.InputType;
	LocalTransparencyModifier: number;
	/** Determines whether building tools (in-game and studio) can manipulate this Part.  If true, no editing allowed.  If false, editing is allowed. */
	Locked: boolean;
	/** If true the part will be massless when welded to another part that is not massless. The part will still have mass like a normal part if it is an assembly root part according to GetRootPart(). */
	Massless: boolean;
	/** Specifies the look and feel the Part should have.  Note: this does not define the color the Part is, see BrickColor for that. [More info](http://wiki.roblox.com/index.php/Material) */
	Material: Enum.Material;
	/** Rotation around X, Y, and Z axis.  Rotations applied in YXZ order. */
	Orientation: Vector3;
	Position: Vector3;
	readonly ReceiveAge: number;
	/** Specifies how shiny the Part is. A value of 1 is completely reflective (chrome), while a value of 0 is no reflectance (concrete wall) */
	Reflectance: number;
	/** Sets the value for the smallest change in size allowable by the Resize(NormalId, int) function. */
	readonly ResizeIncrement: number;
	/** Sets the value for the faces allowed to be resized by the Resize(NormalId, int) function. */
	readonly ResizeableFaces: Faces;
	RightParamA: number;
	RightParamB: number;
	RightSurface: Enum.SurfaceType;
	RightSurfaceInput: Enum.InputType;
	/** An integer from -127 to 127. Compares before other all other part properties besides massless for deciding which part is the assembly root part according to GetRootPart(). */
	RootPriority: number;
	RotVelocity: Vector3;
	Rotation: Vector3;
	Size: Vector3;
	TopParamA: number;
	TopParamB: number;
	TopSurface: Enum.SurfaceType;
	TopSurfaceInput: Enum.InputType;
	/** Sets how visible an object is. A value of 1 makes the object invisible, while a value of 0 makes the object opaque. */
	Transparency: number;
	/** How fast the Part is traveling in studs/second. This property is NOT recommended to be modified directly, unless there is good reason.  Otherwise, try using a BodyForce to move a Part. */
	Velocity: Vector3;
	/** Destroys SurfaceJoints with all parts that are touching this Instance (including internal joints in the Instance, as in a Model). */
	BreakJoints(): void;

	CanCollideWith(part: BasePart): boolean;
	/** @rbxts server */
	CanSetNetworkOwnership(): LuaTuple<[boolean, string | undefined]>;

	GetConnectedParts(recursive?: boolean): Array<BasePart>;

	GetJoints(): Array<Constraint | JointInstance>;
	/** Returns a number that is the mass of this Instance.  Mass of a Part is immutable, and is changed only by the size of the Part. */
	GetMass(): number;
	/** @rbxts server */
	GetNetworkOwner(): Player | undefined;
	/** @rbxts server */
	GetNetworkOwnershipAuto(): boolean;

	GetRootPart(): BasePart;

	GetTouchingParts(): Array<BasePart>;
	IsGrounded(): boolean;
	/** Creates the appropriate SurfaceJoints with all parts that are touching this Instance (including internal joints in the Instance, as in a Model).  This uses the SurfaceTypes defined on the surfaces of parts to create the appropriate welds. [More info](http://wiki.roblox.com/index.php/MakeJoints) */
	MakeJoints(): void;
	/** Resizes a Part in the direction of the face defined by 'NormalId', by the amount specified by 'deltaAmount'. If the operation will expand the part to intersect another Instance, the part will not resize at all.  Return true if the call is successful, false otherwise. */
	Resize(normalId: CastsToEnum<Enum.NormalId>, deltaAmount: number): boolean;
	/** @rbxts server */
	SetNetworkOwner(playerInstance?: Player): void;
	/** @rbxts server */
	SetNetworkOwnershipAuto(): void;
	/** @rbxts server */
	SubtractAsync(parts: Array<BasePart>, collisionfidelity?: CastsToEnum<Enum.CollisionFidelity>): UnionOperation;
	/** @rbxts server */
	UnionAsync(parts: Array<BasePart>, collisionfidelity?: CastsToEnum<Enum.CollisionFidelity>): UnionOperation;
	/** Fired when the part stops touching another part */
	readonly TouchEnded: RBXScriptSignal<(otherPart: BasePart) => void>;

	readonly Touched: RBXScriptSignal<(otherPart: BasePart) => void>;
}

interface CornerWedgePart extends BasePart {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CornerWedgePart";
}

interface FormFactorPart extends BasePart {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "FormFactorPart" | "Part" | "WedgePart" | "FlagStand" | "Platform" | "Seat" | "SkateboardPlatform" | "SpawnLocation";
}

interface Part extends FormFactorPart {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Part" | "FlagStand" | "Platform" | "Seat" | "SkateboardPlatform" | "SpawnLocation";
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	Shape: Enum.PartType;
}

interface FlagStand extends Part {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "FlagStand";
	TeamColor: BrickColor;

	readonly FlagCaptured: RBXScriptSignal<(player: Player) => void>;
}

interface Platform extends Part {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Platform";
}

interface Seat extends Part {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Seat";
	Disabled: boolean;
	readonly Occupant?: Humanoid;

	Sit(humanoid: Humanoid): void;
}

interface SkateboardPlatform extends Part {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SkateboardPlatform";
	readonly Controller?: SkateboardController;
	readonly ControllingHumanoid?: Humanoid;
	Steer: number;
	StickyWheels: boolean;
	Throttle: number;
	ApplySpecificImpulse(impulseWorld: Vector3): void;

	readonly Equipped: RBXScriptSignal<(humanoid: Humanoid, skateboardController: SkateboardController) => void>;
	readonly MoveStateChanged: RBXScriptSignal<(newState: Enum.MoveState, oldState: Enum.MoveState) => void>;

	readonly Unequipped: RBXScriptSignal<(humanoid: Humanoid) => void>;
}

interface SpawnLocation extends Part {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SpawnLocation";
	/** [NO DOCUMENTATION] */
	AllowTeamChangeOnTouch: boolean;
	/** [NO DOCUMENTATION] */
	Duration: number;
	/** [NO DOCUMENTATION] */
	Enabled: boolean;
	/** [NO DOCUMENTATION] */
	Neutral: boolean;
	/** [NO DOCUMENTATION] */
	TeamColor: BrickColor;
}

interface WedgePart extends FormFactorPart {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "WedgePart";
}

interface Terrain extends BasePart {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Terrain";
	readonly MaxExtents: Region3int16;
	WaterColor: Color3;
	WaterReflectance: number;
	WaterTransparency: number;
	WaterWaveSize: number;
	WaterWaveSpeed: number;
	CellCenterToWorld(x: number, y: number, z: number): Vector3;
	CellCornerToWorld(x: number, y: number, z: number): Vector3;
	Clear(): void;

	CopyRegion(region: Region3int16): TerrainRegion;
	CountCells(): number;
	FillBall(center: Vector3, radius: number, material: CastsToEnum<Enum.Material>): void;
	FillBlock(cframe: CFrame, size: Vector3, material: CastsToEnum<Enum.Material>): void;
	FillRegion(region: Region3, resolution: number, material: CastsToEnum<Enum.Material>): void;
	GetMaterialColor(material: CastsToEnum<Enum.Material>): Color3;

	PasteRegion(region: TerrainRegion, corner: Vector3int16, pasteEmptyCells: boolean): void;

	ReadVoxels(
		region: Region3,
		resolution: number,
	): LuaTuple<[ReadVoxelsArray<Enum.Material>, ReadVoxelsArray<number>]>;
	SetMaterialColor(material: CastsToEnum<Enum.Material>, value: Color3): void;
	WorldToCell(position: Vector3): Vector3;
	WorldToCellPreferEmpty(position: Vector3): Vector3;
	WorldToCellPreferSolid(position: Vector3): Vector3;

	WriteVoxels(
		region: Region3,
		resolution: number,
		materials: Array<Array<Array<CastsToEnum<Enum.Material>>>>,
		occupancy: Array<Array<Array<number>>>,
	): void;
}

interface TriangleMeshPart extends BasePart {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TriangleMeshPart" | "MeshPart" | "PartOperation" | "NegateOperation" | "UnionOperation";
}

interface MeshPart extends TriangleMeshPart {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "MeshPart";
	/** [NO DOCUMENTATION] */
	readonly MeshId: string;
	/** [NO DOCUMENTATION] */
	readonly RenderFidelity: Enum.RenderFidelity;
	/** [NO DOCUMENTATION] */
	TextureID: string;
}

interface PartOperation extends TriangleMeshPart {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PartOperation" | "NegateOperation" | "UnionOperation";
	/** [NO DOCUMENTATION] */
	readonly RenderFidelity: Enum.RenderFidelity;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly TriangleCount: number;
	/** [NO DOCUMENTATION] */
	UsePartColor: boolean;
}

interface NegateOperation extends PartOperation {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "NegateOperation";
}

interface UnionOperation extends PartOperation {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UnionOperation";
}

interface TrussPart extends BasePart {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TrussPart";
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	Style: Enum.Style;
}

interface VehicleSeat extends BasePart {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "VehicleSeat";
	readonly AreHingesDetected: number;
	Disabled: boolean;
	HeadsUpDisplay: boolean;
	MaxSpeed: number;
	readonly Occupant?: Humanoid;
	Steer: number;
	SteerFloat: number;
	Throttle: number;
	ThrottleFloat: number;
	Torque: number;
	TurnSpeed: number;

	Sit(humanoid: Humanoid): void;
}

interface Model extends PVInstance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Model" | "Status" | "Workspace";
	/** A Part that serves as a reference for the Model's CFrame. Used in conjunction with GetModelPrimaryPartCFrame and SetModelPrimaryPartCFrame. Use this to rotate/translate all Parts relative to the PrimaryPart. */
	PrimaryPart?: BasePart;
	/** Breaks all surface joints contained within */
	BreakJoints(): void;

	GetBoundingBox(): LuaTuple<[CFrame, Vector3]>;
	GetExtentsSize(): Vector3;
	/** Returns the cframe of the Model.PrimaryPart. If PrimaryPart is nil, then this function will throw an error. */
	GetPrimaryPartCFrame(): CFrame;
	/** Creates the appropriate SurfaceJoints between all touching Parts contrained within the model. Technically, this function calls MakeJoints() on all Parts inside the model. */
	MakeJoints(): void;
	/** Moves the centroid of the Model to the specified location, respecting all relative distances between parts in the model. */
	MoveTo(position: Vector3): void;
	/** Sets the cframe of the Model.PrimaryPart. If PrimaryPart is nil, then this function will throw an error. This also sets the cframe of all descendant Parts relative to the cframe change to PrimaryPart. */
	SetPrimaryPartCFrame(cframe: CFrame): void;
	/** Similar to MoveTo(), except instead of moving to an explicit location, we use the model's current CFrame location and offset it. */
	TranslateBy(delta: Vector3): void;
}

interface Status extends Model {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Status";
}

interface Workspace extends Model {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Workspace";
	AllowThirdPartySales: boolean;
	CurrentCamera?: Camera;
	DistributedGameTime: number;
	/** Sets the height at which falling characters and parts are destroyed. This property is not scriptable and can only be set in Studio */
	readonly FallenPartsDestroyHeight: number;
	readonly FilteringEnabled: boolean;
	Gravity: number;
	StreamingEnabled: boolean;

	Terrain: Terrain;
	/** Return type is (BasePart, Vector3) if the ray hits.  If it misses it will return (nil, PointAtEndOfRay) */
	FindPartOnRay(
		ray: Ray,
		ignoreDescendantsInstance?: Instance,
		terrainCellsAreCubes?: boolean,
		ignoreWater?: boolean,
	): LuaTuple<[BasePart | undefined, Vector3, Vector3, Enum.Material]>;
	/** Return type is (BasePart, Vector3) if the ray hits.  If it misses it will return (nil, PointAtEndOfRay) */
	FindPartOnRayWithIgnoreList(
		ray: Ray,
		ignoreDescendantsTable: Array<Instance>,
		terrainCellsAreCubes?: boolean,
		ignoreWater?: boolean,
	): LuaTuple<[BasePart | undefined, Vector3, Vector3, Enum.Material]>;

	FindPartOnRayWithWhitelist(
		ray: Ray,
		whitelistDescendantsTable: Array<Instance>,
		ignoreWater?: boolean,
	): LuaTuple<[BasePart | undefined, Vector3, Vector3, Enum.Material]>;
	/** Returns parts in the area defined by the Region3, up to specified maxCount or 100, whichever is less */
	FindPartsInRegion3(region: Region3, ignoreDescendantsInstance?: Instance, maxParts?: number): Array<Instance>;
	/** Returns parts in the area defined by the Region3, up to specified maxCount or 100, whichever is less */
	FindPartsInRegion3WithIgnoreList(region: Region3, ignoreDescendantsTable: Array<Instance>, maxParts?: number): Array<Instance>;
	FindPartsInRegion3WithWhiteList(region: Region3, whitelistDescendantsTable: Array<Instance>, maxParts?: number): Array<Instance>;
	GetNumAwakeParts(): number;
	GetPhysicsThrottling(): number;
	GetRealPhysicsFPS(): number;
	IsRegion3Empty(region: Region3, ignoreDescendentsInstance?: Instance): boolean;
	IsRegion3EmptyWithIgnoreList(region: Region3, ignoreDescendentsTable: Array<Instance>): boolean;
	JoinToOutsiders(objects: Array<Instance>, jointType: CastsToEnum<Enum.JointCreationMode>): void;
	PGSIsEnabled(): boolean;
	UnjoinFromOutsiders(objects: Array<Instance>): void;
}

interface PackageLink extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PackageLink";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly PackageId: string;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	readonly VersionNumber: number;
}

interface PackageService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PackageService";
}

interface Pages extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Pages" | "DataStorePages" | "FriendPages" | "InventoryPages" | "StandardPages" | "EmotesPages";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly IsFinished: boolean;
	/** [NO DOCUMENTATION] */
	GetCurrentPage(): unknown;
	/** [NO DOCUMENTATION] *
	 * Tags: Yields
	 */
	AdvanceToNextPageAsync(): void;
}

interface DataStorePages extends Pages {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "DataStorePages";
}

interface FriendPages extends Pages {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "FriendPages";
}

interface InventoryPages extends Pages {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "InventoryPages" | "EmotesPages";
}

interface EmotesPages extends InventoryPages {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "EmotesPages";
}

interface StandardPages extends Pages {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "StandardPages";
}

interface PartOperationAsset extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PartOperationAsset";
}

interface ParticleEmitter extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ParticleEmitter";
	/** [NO DOCUMENTATION] */
	Acceleration: Vector3;
	/** [NO DOCUMENTATION] */
	Color: ColorSequence;
	/** [NO DOCUMENTATION] */
	Drag: number;
	/** [NO DOCUMENTATION] */
	EmissionDirection: Enum.NormalId;
	/** [NO DOCUMENTATION] */
	Enabled: boolean;
	/** [NO DOCUMENTATION] */
	Lifetime: NumberRange;
	/** [NO DOCUMENTATION] */
	LightEmission: number;
	/** Specifies the amount of influence lighting has on the particle emmitter. A value of 0 is unlit, 1 is fully lit. Fractional values blend from unlit to lit. */
	LightInfluence: number;
	/** [NO DOCUMENTATION] */
	LockedToPart: boolean;
	/** [NO DOCUMENTATION] */
	Rate: number;
	/** [NO DOCUMENTATION] */
	RotSpeed: NumberRange;
	/** [NO DOCUMENTATION] */
	Rotation: NumberRange;
	/** [NO DOCUMENTATION] */
	Size: NumberSequence;
	/** [NO DOCUMENTATION] */
	Speed: NumberRange;
	/** [NO DOCUMENTATION] */
	SpreadAngle: Vector2;
	/** [NO DOCUMENTATION] */
	Texture: string;
	/** [NO DOCUMENTATION] */
	Transparency: NumberSequence;
	/** [NO DOCUMENTATION] */
	VelocityInheritance: number;
	/** [NO DOCUMENTATION] */
	ZOffset: number;
	/** [NO DOCUMENTATION] */
	Clear(): void;
	/** [NO DOCUMENTATION] */
	Emit(particleCount?: number): void;
}

interface Path extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Path";
	readonly Status: Enum.PathStatus;

	GetWaypoints(): Array<PathWaypoint>;
	CheckOcclusionAsync(start: number): number;
	ComputeAsync(start: Vector3, finish: Vector3): void;
	readonly Blocked: RBXScriptSignal<(blockedWaypointIdx: number) => void>;
}

interface PathfindingService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PathfindingService";

	CreatePath(agentParameters?: AgentParameters): Path;

	FindPathAsync(start: Vector3, finish: Vector3): Path;
}

interface PhysicsPacketCache extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PhysicsPacketCache";
}

interface PhysicsService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PhysicsService";

	CollisionGroupContainsPart(name: string, part: BasePart): boolean;
	CollisionGroupContainsPart(name: string, part: BasePart): boolean;
	CollisionGroupSetCollidable(name1: string, name2: string, collidable: boolean): void;
	CollisionGroupsAreCollidable(name1: string, name2: string): boolean;
	CreateCollisionGroup(name: string): number;
	GetCollisionGroupId(name: string): number;
	GetCollisionGroupName(name: number): string;

	GetCollisionGroups(): Array<CollisionGroupInfo>;
	GetMaxCollisionGroups(): number;
	RemoveCollisionGroup(name: string): void;
	RenameCollisionGroup(from: string, to: string): void;

	SetPartCollisionGroup(part: BasePart, name: string): void;
}

interface PhysicsSettings extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PhysicsSettings";
	/** [NO DOCUMENTATION] */
	AllowSleep: boolean;
	/** [NO DOCUMENTATION] */
	AreAnchorsShown: boolean;
	/** [NO DOCUMENTATION] */
	AreAssembliesShown: boolean;
	/** [NO DOCUMENTATION] */
	AreAwakePartsHighlighted: boolean;
	/** [NO DOCUMENTATION] */
	AreBodyTypesShown: boolean;
	/** [NO DOCUMENTATION] */
	AreContactIslandsShown: boolean;
	/** [NO DOCUMENTATION] */
	AreContactPointsShown: boolean;
	/** [NO DOCUMENTATION] */
	AreJointCoordinatesShown: boolean;
	/** [NO DOCUMENTATION] */
	AreMechanismsShown: boolean;
	/** [NO DOCUMENTATION] */
	AreModelCoordsShown: boolean;
	/** [NO DOCUMENTATION] */
	AreOwnersShown: boolean;
	/** [NO DOCUMENTATION] */
	ArePartCoordsShown: boolean;
	/** [NO DOCUMENTATION] */
	AreRegionsShown: boolean;
	/** [NO DOCUMENTATION] */
	AreUnalignedPartsShown: boolean;
	/** [NO DOCUMENTATION] */
	AreWorldCoordsShown: boolean;
	/** [NO DOCUMENTATION] */
	DisableCSGv2: boolean;
	/** [NO DOCUMENTATION] */
	IsReceiveAgeShown: boolean;
	/** [NO DOCUMENTATION] */
	IsTreeShown: boolean;
	/** [NO DOCUMENTATION] */
	PhysicsEnvironmentalThrottle: Enum.EnviromentalPhysicsThrottle;
	/** [NO DOCUMENTATION] */
	ShowDecompositionGeometry: boolean;
	/** [NO DOCUMENTATION] */
	ThrottleAdjustTime: number;
	/** [NO DOCUMENTATION] */
	UseCSGv2: boolean;
}

interface Player extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Player";
	readonly AccountAge: number;
	AutoJumpEnabled: boolean;
	CameraMaxZoomDistance: number;
	CameraMinZoomDistance: number;
	/** An enum that describes how a Player's camera is allowed to behave. [More info](http://wiki.roblox.com/index.php/CameraMode). */
	CameraMode: Enum.CameraMode;
	CanLoadCharacterAppearance: boolean;
	Character?: Model;
	CharacterAppearanceId: number;
	DevCameraOcclusionMode: Enum.DevCameraOcclusionMode;
	DevComputerCameraMode: Enum.DevComputerCameraMovementMode;
	DevComputerMovementMode: Enum.DevComputerMovementMode;
	DevEnableMouseLock: boolean;
	DevTouchCameraMode: Enum.DevTouchCameraMovementMode;
	DevTouchMovementMode: Enum.DevTouchMovementMode;
	readonly FollowUserId: number;
	readonly GameplayPaused: boolean;
	HealthDisplayDistance: number;
	readonly LocaleId: string;
	readonly MembershipType: Enum.MembershipType;
	NameDisplayDistance: number;
	Neutral: boolean;

	ReplicationFocus: BasePart | undefined;
	RespawnLocation?: SpawnLocation;
	Team?: Team;
	TeamColor: BrickColor;

	readonly UserId: number;
	ClearCharacterAppearance(): void;
	DistanceFromCharacter(point: Vector3): number;

	GetJoinData(): PlayerJoinInfo;

	GetMouse(): PlayerMouse;
	HasAppearanceLoaded(): boolean;
	Kick(message?: string): void;
	Move(walkDirection: Vector3, relativeToCamera?: boolean): void;
	/** ### TS Usage
	 * One should check the LocationType of each member of this array in order to verify which members are present. Should be compared to the LocationType const enum.
	 */
	GetFriendsOnline(maxFriends?: number): Array<FriendOnlineInfo>;
	GetRankInGroup(groupId: number): number;
	GetRoleInGroup(groupId: number): string;
	IsFriendsWith(userId: number): boolean;
	IsInGroup(groupId: number): boolean;
	/** Loads in a new character for this player.  This will replace the player's current character, if they have one. This should be used in conjunction with Players.CharacterAutoLoads to control spawning of characters. This function only works from a server-side script (NOT a LocalScript). */
	/** @rbxts server */
	LoadCharacter(): void;
	/** @rbxts server */
	LoadCharacterWithHumanoidDescription(humanoidDescription: HumanoidDescription): void;

	readonly CharacterAdded: RBXScriptSignal<(character: Model) => void>;

	readonly CharacterAppearanceLoaded: RBXScriptSignal<(character: Model) => void>;

	readonly CharacterRemoving: RBXScriptSignal<(character: Model) => void>;

	readonly Chatted: RBXScriptSignal<(message: string, recipient: Instance) => void>;
	/** Fired periodically after the user has been AFK for a while.  Currently this event is only fired for the *local* Player.  "time" is the time in seconds that the user has been idle. */
	readonly Idled: RBXScriptSignal<(time: number) => void>;
	readonly OnTeleport: RBXScriptSignal<(teleportState: Enum.TeleportState, placeId: number, spawnName: string) => void>;
}

interface PlayerScripts extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PlayerScripts";
	/** [NO DOCUMENTATION] */
	ClearComputerCameraMovementModes(): void;
	/** [NO DOCUMENTATION] */
	ClearComputerMovementModes(): void;
	/** [NO DOCUMENTATION] */
	ClearTouchCameraMovementModes(): void;
	/** [NO DOCUMENTATION] */
	ClearTouchMovementModes(): void;
	/** [NO DOCUMENTATION] */
	RegisterComputerCameraMovementMode(cameraMovementMode: CastsToEnum<Enum.ComputerCameraMovementMode>): void;
	/** [NO DOCUMENTATION] */
	RegisterComputerMovementMode(movementMode: CastsToEnum<Enum.ComputerMovementMode>): void;
	/** [NO DOCUMENTATION] */
	RegisterTouchCameraMovementMode(cameraMovementMode: CastsToEnum<Enum.TouchCameraMovementMode>): void;
	/** [NO DOCUMENTATION] */
	RegisterTouchMovementMode(movementMode: CastsToEnum<Enum.TouchMovementMode>): void;
}

interface Players extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Players";
	readonly BubbleChat: boolean;
	/** Set to true, when a player joins a game, they get a character automatically, as well as when they die.  When set to false, characters do not auto load and will only load in using Player:LoadCharacter(). */
	CharacterAutoLoads: boolean;
	readonly ClassicChat: boolean;
	/** @rbxts client */
	readonly LocalPlayer: Player;
	readonly MaxPlayers: number;
	readonly PreferredPlayers: number;
	RespawnTime: number;

	GetPlayerByUserId(userId: number): Player | undefined;

	GetPlayerFromCharacter(character: Model): Player | undefined;

	GetPlayers(): Array<Player>;

	GetCharacterAppearanceAsync(userId: number): Model | undefined;

	GetCharacterAppearanceInfoAsync(userId: number): CharacterAppearanceInfo;

	GetFriendsAsync(userId: number): FriendPages;

	GetHumanoidDescriptionFromOutfitId(outfitId: number): HumanoidDescription;

	GetHumanoidDescriptionFromUserId(userId: number): HumanoidDescription;
	GetNameFromUserIdAsync(userId: number): string;
	GetUserIdFromNameAsync(userName: string): number;

	GetUserThumbnailAsync(
		userId: number,
		thumbnailType: CastsToEnum<Enum.ThumbnailType>,
		thumbnailSize: CastsToEnum<Enum.ThumbnailSize>,
	): LuaTuple<[string, boolean]>;

	readonly PlayerAdded: RBXScriptSignal<(player: Player) => void>;

	readonly PlayerRemoving: RBXScriptSignal<(player: Player) => void>;
}

interface Plugin extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Plugin";
	readonly CollisionEnabled: boolean;
	readonly GridSize: number;
}

interface PluginAction extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PluginAction";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly ActionId: string;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly AllowBinding: boolean;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly StatusTip: string;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Text: string;
}

interface PluginDragEvent extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PluginDragEvent";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Data: string;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly MimeType: string;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Position: Vector2;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Sender: string;
}

interface PluginGuiService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PluginGuiService";
}

interface PluginManager extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PluginManager";
}

interface PluginMenu extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PluginMenu";
	Icon: string;
	Title: string;
}

interface PluginToolbar extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PluginToolbar";
}

interface PluginToolbarButton extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PluginToolbarButton";
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	ClickableWhenViewportHidden: boolean;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	Enabled: boolean;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	Icon: string;
}

interface PointsService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PointsService";
	/** Fired when points are successfully awarded 'userId'. Also returns the updated balance of points for usedId in universe via 'userBalanceInUniverse', total points via 'userTotalBalance', and the amount points that were awarded via 'pointsAwarded'. This event fires on the server and also all clients in the game that awarded the points. */
	readonly PointsAwarded: RBXScriptSignal<(userId: number, pointsAwarded: number, userBalanceInGame: number, userTotalBalance: number) => void>;
}

interface Pose extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Pose";
	CFrame: CFrame;
	EasingDirection: Enum.PoseEasingDirection;
	EasingStyle: Enum.PoseEasingStyle;
	Weight: number;

	AddSubPose(pose: Pose): void;
	GetSubPoses(): Array<Instance>;

	RemoveSubPose(pose: Pose): void;
}

interface PostEffect extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PostEffect" | "BloomEffect" | "BlurEffect" | "ColorCorrectionEffect" | "SunRaysEffect";
	/** [NO DOCUMENTATION] */
	Enabled: boolean;
}

interface BloomEffect extends PostEffect {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BloomEffect";
	/** [NO DOCUMENTATION] */
	Intensity: number;
	/** [NO DOCUMENTATION] */
	Size: number;
	/** [NO DOCUMENTATION] */
	Threshold: number;
}

interface BlurEffect extends PostEffect {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BlurEffect";
	/** [NO DOCUMENTATION] */
	Size: number;
}

interface ColorCorrectionEffect extends PostEffect {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ColorCorrectionEffect";
	/** [NO DOCUMENTATION] */
	Brightness: number;
	/** [NO DOCUMENTATION] */
	Contrast: number;
	/** [NO DOCUMENTATION] */
	Saturation: number;
	/** [NO DOCUMENTATION] */
	TintColor: Color3;
}

interface SunRaysEffect extends PostEffect {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SunRaysEffect";
	/** [NO DOCUMENTATION] */
	Intensity: number;
	/** [NO DOCUMENTATION] */
	Spread: number;
}

interface RbxAnalyticsService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RbxAnalyticsService";
}

interface ReflectionMetadata extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ReflectionMetadata";
}

interface ReflectionMetadataCallbacks extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ReflectionMetadataCallbacks";
}

interface ReflectionMetadataClasses extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ReflectionMetadataClasses";
}

interface ReflectionMetadataEnums extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ReflectionMetadataEnums";
}

interface ReflectionMetadataEvents extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ReflectionMetadataEvents";
}

interface ReflectionMetadataFunctions extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ReflectionMetadataFunctions";
}

interface ReflectionMetadataItem extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ReflectionMetadataItem" | "ReflectionMetadataClass" | "ReflectionMetadataEnum" | "ReflectionMetadataEnumItem" | "ReflectionMetadataMember";
	/** [NO DOCUMENTATION] */
	Browsable: boolean;
	/** [NO DOCUMENTATION] */
	ClassCategory: string;
	/** [NO DOCUMENTATION] */
	ClientOnly: boolean;
	/** [NO DOCUMENTATION] */
	Constraint: string;
	/** [NO DOCUMENTATION] */
	Deprecated: boolean;
	/** [NO DOCUMENTATION] */
	EditingDisabled: boolean;
	/** [NO DOCUMENTATION] */
	IsBackend: boolean;
	/** [NO DOCUMENTATION] */
	ScriptContext: string;
	/** [NO DOCUMENTATION] */
	ServerOnly: boolean;
	/** [NO DOCUMENTATION] */
	UIMaximum: number;
	/** [NO DOCUMENTATION] */
	UIMinimum: number;
	/** [NO DOCUMENTATION] */
	UINumTicks: number;
	/** [NO DOCUMENTATION] */
	summary: string;
}

interface ReflectionMetadataClass extends ReflectionMetadataItem {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ReflectionMetadataClass";
	/** [NO DOCUMENTATION] */
	ExplorerImageIndex: number;
	/** [NO DOCUMENTATION] */
	ExplorerOrder: number;
	/** [NO DOCUMENTATION] */
	Insertable: boolean;
	/** [NO DOCUMENTATION] */
	PreferredParent: string;
	/** [NO DOCUMENTATION] */
	PreferredParents: string;
}

interface ReflectionMetadataEnum extends ReflectionMetadataItem {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ReflectionMetadataEnum";
}

interface ReflectionMetadataEnumItem extends ReflectionMetadataItem {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ReflectionMetadataEnumItem";
}

interface ReflectionMetadataMember extends ReflectionMetadataItem {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ReflectionMetadataMember";
}

interface ReflectionMetadataProperties extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ReflectionMetadataProperties";
}

interface ReflectionMetadataYieldFunctions extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ReflectionMetadataYieldFunctions";
}

interface RemoteEvent extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RemoteEvent";

	FireAllClients(...arguments: Array<unknown>): void;

	FireClient(player: Player, ...arguments: Array<unknown>): void;

	FireServer(...arguments: Array<unknown>): void;

	readonly OnClientEvent: RBXScriptSignal<(...arguments: Array<unknown>) => void, true>;

	readonly OnServerEvent: RBXScriptSignal<(player: Player, ...arguments: Array<unknown>) => void>;
}

interface RemoteFunction extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RemoteFunction";

	InvokeClient(player: Player, ...arguments: Array<any>): unknown;

	InvokeServer<R = unknown>(...arguments: Array<any>): R;

	OnClientInvoke: (arguments: Array<any>) => void;

	OnServerInvoke: (player: Player, arguments: Array<any>) => void;
}

interface RenderSettings extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RenderSettings";
	/** [NO DOCUMENTATION] */
	AutoFRMLevel: number;
	/** [NO DOCUMENTATION] */
	EagerBulkExecution: boolean;
	/** [NO DOCUMENTATION] */
	EditQualityLevel: Enum.QualityLevel;
	/** [NO DOCUMENTATION] *
	 * Tags: Hidden, NotReplicated
	 */
	EnableFRM: boolean;
	/** [NO DOCUMENTATION] */
	ExportMergeByMaterial: boolean;
	/** [NO DOCUMENTATION] */
	FrameRateManager: Enum.FramerateManagerMode;
	/** [NO DOCUMENTATION] */
	GraphicsMode: Enum.GraphicsMode;
	/** [NO DOCUMENTATION] */
	MeshCacheSize: number;
	/** [NO DOCUMENTATION] */
	QualityLevel: Enum.QualityLevel;
	/** [NO DOCUMENTATION] */
	ReloadAssets: boolean;
	/** [NO DOCUMENTATION] */
	RenderCSGTrianglesDebug: boolean;
	/** [NO DOCUMENTATION] */
	ShowBoundingBoxes: boolean;
	/** [NO DOCUMENTATION] */
	GetMaxQualityLevel(): number;
}

interface RenderingTest extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RenderingTest";
	/** [NO DOCUMENTATION] */
	CFrame: CFrame;
	/** [NO DOCUMENTATION] */
	ComparisonDiffThreshold: number;
	/** [NO DOCUMENTATION] */
	ComparisonMethod: Enum.RenderingTestComparisonMethod;
	/** [NO DOCUMENTATION] */
	ComparisonPsnrThreshold: number;
	/** [NO DOCUMENTATION] */
	Description: string;
	/** [NO DOCUMENTATION] */
	FieldOfView: number;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	Orientation: Vector3;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	Position: Vector3;
	/** [NO DOCUMENTATION] */
	QualityLevel: number;
	/** [NO DOCUMENTATION] */
	ShouldSkip: boolean;
	/** [NO DOCUMENTATION] */
	Ticket: string;
	/** [NO DOCUMENTATION] */
	RenderdocTriggerCapture(): void;
}

interface ReplicatedFirst extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ReplicatedFirst";
	/** [NO DOCUMENTATION] */
	RemoveDefaultLoadingScreen(): void;
}

interface ReplicatedStorage extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ReplicatedStorage";
}

interface RobloxPluginGuiService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RobloxPluginGuiService";
}

interface RobloxReplicatedStorage extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RobloxReplicatedStorage";
}

interface RunService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RunService";
	/** [NO DOCUMENTATION] */
	BindToRenderStep(name: string, priority: number, callback: Function): void;
	/** [NO DOCUMENTATION] */
	IsClient(): boolean;
	/** [NO DOCUMENTATION] */
	IsRunMode(): boolean;
	/** [NO DOCUMENTATION] */
	IsRunning(): boolean;
	/** [NO DOCUMENTATION] */
	IsServer(): boolean;
	/** [NO DOCUMENTATION] */
	IsStudio(): boolean;
	/** [NO DOCUMENTATION] */
	UnbindFromRenderStep(name: string): void;
	/** [NO DOCUMENTATION] */
	readonly Heartbeat: RBXScriptSignal<(step: number) => void>;
	/** [NO DOCUMENTATION] */
	readonly RenderStepped: RBXScriptSignal<(step: number) => void>;
	/** [NO DOCUMENTATION] */
	readonly Stepped: RBXScriptSignal<(time: number, step: number) => void>;
}

interface RuntimeScriptService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RuntimeScriptService";
}

interface ScriptContext extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ScriptContext";
	/** [NO DOCUMENTATION] */
	readonly Error: RBXScriptSignal<(message: string, stackTrace: string, script: Instance) => void>;
}

interface ScriptDebugger extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ScriptDebugger";
	readonly CurrentLine: number;
	readonly IsDebugging: boolean;
	readonly IsPaused: boolean;
	readonly Script?: Instance;
	AddWatch(expression: string): Instance | undefined;
	GetBreakpoints(): Array<Instance>;

	GetGlobals(): Map<string, any>;

	GetLocals(stackFrame?: number): Map<string, any>;
	GetStack(): unknown;

	GetUpvalues(stackFrame?: number): Map<string, any>;
	GetWatchValue(watch: Instance): unknown;
	GetWatches(): Array<Instance>;
	SetBreakpoint(line: number): Instance | undefined;
	SetGlobal(name: string, value?: any): void;
	SetLocal(name: string, value?: any, stackFrame?: number): void;
	SetUpvalue(name: string, value?: any, stackFrame?: number): void;
	readonly BreakpointAdded: RBXScriptSignal<(breakpoint: Instance) => void>;
	readonly BreakpointRemoved: RBXScriptSignal<(breakpoint: Instance) => void>;
	readonly EncounteredBreak: RBXScriptSignal<(line: number) => void>;
	readonly Resuming: RBXScriptSignal<() => void>;
	readonly WatchAdded: RBXScriptSignal<(watch: Instance) => void>;
	readonly WatchRemoved: RBXScriptSignal<(watch: Instance) => void>;
}

interface ScriptService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ScriptService";
}

interface Selection extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Selection";
	/** [NO DOCUMENTATION] */
	readonly SelectionChanged: RBXScriptSignal<() => void>;
}

/** @rbxts server */
interface ServerScriptService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ServerScriptService";
}

/** @rbxts server */
interface ServerStorage extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ServerStorage";
}

interface ServiceProvider extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ServiceProvider" | "DataModel" | "GenericSettings" | "AnalysticsSettings" | "GlobalSettings" | "UserSettings";

	FindService(className: string): Instance | undefined;
	FindService(className: string): Services[keyof Services] | undefined;

	GetService<T extends keyof Services>(className: T): Services[T];
	GetService(className: string): Services[keyof Services] | undefined;
	readonly Close: RBXScriptSignal<() => void>;

	readonly ServiceAdded: RBXScriptSignal<(service: Services[keyof Services]) => void>;

	readonly ServiceRemoving: RBXScriptSignal<(service: Services[keyof Services]) => void>;
}

interface DataModel extends ServiceProvider {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "DataModel";
	readonly CreatorId: number;
	readonly CreatorType: Enum.CreatorType;
	readonly GameId: number;
	readonly Genre: Enum.Genre;
	readonly JobId: string;
	readonly PlaceId: number;
	readonly PlaceVersion: number;
	readonly PrivateServerId: string;
	readonly PrivateServerOwnerId: number;

	readonly Workspace: Workspace;
	BindToClose(callback: Function): void;
	IsLoaded(): boolean;
	readonly GraphicsQualityChangeRequest: RBXScriptSignal<(betterQuality: boolean) => void>;
	/** Fires when the game finishes loading.  Use this to know when to remove your custom loading gui.  It is best to check IsLoaded() before connecting to this event, as the game may load before the event is connected to. */
	readonly Loaded: RBXScriptSignal<() => void>;
}

interface GenericSettings extends ServiceProvider {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "GenericSettings" | "AnalysticsSettings" | "GlobalSettings" | "UserSettings";
}

interface AnalysticsSettings extends GenericSettings {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "AnalysticsSettings";
}

interface GlobalSettings extends GenericSettings {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "GlobalSettings";
	/** [NO DOCUMENTATION] */
	GetFFlag(name: string): boolean;
	/** [NO DOCUMENTATION] */
	GetFVariable(name: string): string;
}

interface UserSettings extends GenericSettings {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UserSettings";
	/** [NO DOCUMENTATION] */
	IsUserFeatureEnabled(name: string): boolean;
	/** [NO DOCUMENTATION] */
	Reset(): void;
}

interface Sky extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Sky";
	/** [NO DOCUMENTATION] */
	CelestialBodiesShown: boolean;
	/** [NO DOCUMENTATION] */
	MoonAngularSize: number;
	/** [NO DOCUMENTATION] */
	MoonTextureId: string;
	/** [NO DOCUMENTATION] */
	SkyboxBk: string;
	/** [NO DOCUMENTATION] */
	SkyboxDn: string;
	/** [NO DOCUMENTATION] */
	SkyboxFt: string;
	/** [NO DOCUMENTATION] */
	SkyboxLf: string;
	/** [NO DOCUMENTATION] */
	SkyboxRt: string;
	/** [NO DOCUMENTATION] */
	SkyboxUp: string;
	/** [NO DOCUMENTATION] */
	StarCount: number;
	/** [NO DOCUMENTATION] */
	SunAngularSize: number;
	/** [NO DOCUMENTATION] */
	SunTextureId: string;
}

interface Smoke extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Smoke";
	/** [NO DOCUMENTATION] */
	Color: Color3;
	/** [NO DOCUMENTATION] */
	Enabled: boolean;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	Opacity: number;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	RiseVelocity: number;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	Size: number;
}

interface SocialService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SocialService";

	PromptGameInvite(targetPlayer: Player): void;

	CanSendGameInviteAsync(targetPlayer: Player): boolean;

	readonly GameInvitePromptClosed: RBXScriptSignal<(senderPlayer: Player, recipientIds: Array<number>) => void>;
}

interface Sound extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Sound";
	/** [NO DOCUMENTATION] */
	EmitterSize: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly IsLoaded: boolean;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly IsPaused: boolean;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly IsPlaying: boolean;
	/** [NO DOCUMENTATION] */
	Looped: boolean;
	/** [NO DOCUMENTATION] */
	MaxDistance: number;
	/** The sound will play when it is removed from the Workspace. Looped sounds don't play */
	PlayOnRemove: boolean;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly PlaybackLoudness: number;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	PlaybackSpeed: number;
	/** [NO DOCUMENTATION] */
	Playing: boolean;
	/** [NO DOCUMENTATION] */
	RollOffMode: Enum.RollOffMode;
	/** [NO DOCUMENTATION] */
	SoundGroup?: SoundGroup;
	/** [NO DOCUMENTATION] */
	SoundId: string;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly TimeLength: number;
	/** [NO DOCUMENTATION] */
	TimePosition: number;
	/** [NO DOCUMENTATION] */
	Volume: number;
	/** [NO DOCUMENTATION] */
	Pause(): void;
	/** [NO DOCUMENTATION] */
	Play(): void;
	/** [NO DOCUMENTATION] */
	Resume(): void;
	/** [NO DOCUMENTATION] */
	Stop(): void;
	/** [NO DOCUMENTATION] */
	readonly DidLoop: RBXScriptSignal<(soundId: string, numOfTimesLooped: number) => void>;
	/** [NO DOCUMENTATION] */
	readonly Ended: RBXScriptSignal<(soundId: string) => void>;
	/** [NO DOCUMENTATION] */
	readonly Loaded: RBXScriptSignal<(soundId: string) => void>;
	/** [NO DOCUMENTATION] */
	readonly Paused: RBXScriptSignal<(soundId: string) => void>;
	/** [NO DOCUMENTATION] */
	readonly Played: RBXScriptSignal<(soundId: string) => void>;
	/** [NO DOCUMENTATION] */
	readonly Resumed: RBXScriptSignal<(soundId: string) => void>;
	/** [NO DOCUMENTATION] */
	readonly Stopped: RBXScriptSignal<(soundId: string) => void>;
}

interface SoundEffect extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SoundEffect" | "ChorusSoundEffect" | "CompressorSoundEffect" | "DistortionSoundEffect" | "EchoSoundEffect" | "EqualizerSoundEffect" | "FlangeSoundEffect" | "PitchShiftSoundEffect" | "ReverbSoundEffect" | "TremoloSoundEffect";
	/** [NO DOCUMENTATION] */
	Enabled: boolean;
	/** [NO DOCUMENTATION] */
	Priority: number;
}

interface ChorusSoundEffect extends SoundEffect {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ChorusSoundEffect";
	/** [NO DOCUMENTATION] */
	Depth: number;
	/** [NO DOCUMENTATION] */
	Mix: number;
	/** [NO DOCUMENTATION] */
	Rate: number;
}

interface CompressorSoundEffect extends SoundEffect {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CompressorSoundEffect";
	Attack: number;
	GainMakeup: number;
	Ratio: number;
	Release: number;

	SideChain?: Sound | SoundGroup;
	Threshold: number;
}

interface DistortionSoundEffect extends SoundEffect {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "DistortionSoundEffect";
	/** [NO DOCUMENTATION] */
	Level: number;
}

interface EchoSoundEffect extends SoundEffect {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "EchoSoundEffect";
	/** [NO DOCUMENTATION] */
	Delay: number;
	/** [NO DOCUMENTATION] */
	DryLevel: number;
	/** [NO DOCUMENTATION] */
	Feedback: number;
	/** [NO DOCUMENTATION] */
	WetLevel: number;
}

interface EqualizerSoundEffect extends SoundEffect {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "EqualizerSoundEffect";
	/** [NO DOCUMENTATION] */
	HighGain: number;
	/** [NO DOCUMENTATION] */
	LowGain: number;
	/** [NO DOCUMENTATION] */
	MidGain: number;
}

interface FlangeSoundEffect extends SoundEffect {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "FlangeSoundEffect";
	/** [NO DOCUMENTATION] */
	Depth: number;
	/** [NO DOCUMENTATION] */
	Mix: number;
	/** [NO DOCUMENTATION] */
	Rate: number;
}

interface PitchShiftSoundEffect extends SoundEffect {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "PitchShiftSoundEffect";
	/** [NO DOCUMENTATION] */
	Octave: number;
}

interface ReverbSoundEffect extends SoundEffect {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ReverbSoundEffect";
	/** [NO DOCUMENTATION] */
	DecayTime: number;
	/** [NO DOCUMENTATION] */
	Density: number;
	/** [NO DOCUMENTATION] */
	Diffusion: number;
	/** [NO DOCUMENTATION] */
	DryLevel: number;
	/** [NO DOCUMENTATION] */
	WetLevel: number;
}

interface TremoloSoundEffect extends SoundEffect {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TremoloSoundEffect";
	/** [NO DOCUMENTATION] */
	Depth: number;
	/** [NO DOCUMENTATION] */
	Duty: number;
	/** [NO DOCUMENTATION] */
	Frequency: number;
}

interface SoundGroup extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SoundGroup";
	/** [NO DOCUMENTATION] */
	Volume: number;
}

interface SoundService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SoundService";
	/** The ambient sound environment.  May not work when using hardware sound */
	AmbientReverb: Enum.ReverbType;
	/** the relative distance factor, compared to 1.0 meters. */
	DistanceFactor: number;
	/** The doppler scale is a general scaling factor for how much the pitch varies due to doppler shifting in 3D sound. Doppler is the pitch bending effect when a sound comes towards the listener or moves away from it, much like the effect you hear when a train goes past you with its horn sounding. With dopplerscale you can exaggerate or diminish the effect. */
	DopplerScale: number;
	RespectFilteringEnabled: boolean;
	/** Setting this value makes the sound drop off faster or slower. The higher the value, the faster volume will attenuate, and conversely the lower the value, the slower it will attenuate. For example a rolloff factor of 1 will simulate the real world, where as a value of 2 will make sounds attenuate 2 times quicker. */
	RolloffScale: number;

	GetListener():
		| [Enum.ListenerType.Camera, undefined]
		| [Enum.ListenerType.CFrame, CFrame]
		| [Enum.ListenerType.ObjectCFrame, BasePart]
		| [Enum.ListenerType.ObjectPosition, BasePart];

	PlayLocalSound(sound: Sound): void;

	SetListener(listenerType: CastsToEnum<Enum.ListenerType.Camera>): void;
	SetListener(listenerType: CastsToEnum<Enum.ListenerType.CFrame>, cframe: CFrame): void;
	SetListener(listenerType: CastsToEnum<Enum.ListenerType.ObjectCFrame>, basePart: BasePart): void;
	SetListener(listenerType: CastsToEnum<Enum.ListenerType.ObjectPosition>, basePart: BasePart): void;
}

interface Sparkles extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Sparkles";
	/** [NO DOCUMENTATION] *
	 * Tags: Hidden, NotReplicated
	 */
	Color: Color3;
	/** [NO DOCUMENTATION] */
	Enabled: boolean;
	/** [NO DOCUMENTATION] */
	SparkleColor: Color3;
}

interface SpawnerService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "SpawnerService";
}

interface StarterGear extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "StarterGear";
}

interface StarterPack extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "StarterPack";
}

interface StarterPlayer extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "StarterPlayer";
	/** [NO DOCUMENTATION] *
	 * Tags: Hidden
	 */
	readonly AllowCustomAnimations: boolean;
	/** [NO DOCUMENTATION] */
	AutoJumpEnabled: boolean;
	/** [NO DOCUMENTATION] */
	CameraMaxZoomDistance: number;
	/** [NO DOCUMENTATION] */
	CameraMinZoomDistance: number;
	/** [NO DOCUMENTATION] */
	CameraMode: Enum.CameraMode;
	/** [NO DOCUMENTATION] */
	CharacterJumpHeight: number;
	/** [NO DOCUMENTATION] */
	CharacterJumpPower: number;
	/** [NO DOCUMENTATION] */
	CharacterMaxSlopeAngle: number;
	/** [NO DOCUMENTATION] */
	CharacterUseJumpPower: boolean;
	/** [NO DOCUMENTATION] */
	CharacterWalkSpeed: number;
	/** [NO DOCUMENTATION] */
	DevCameraOcclusionMode: Enum.DevCameraOcclusionMode;
	/** [NO DOCUMENTATION] */
	DevComputerCameraMovementMode: Enum.DevComputerCameraMovementMode;
	/** [NO DOCUMENTATION] */
	DevComputerMovementMode: Enum.DevComputerMovementMode;
	/** [NO DOCUMENTATION] */
	DevTouchCameraMovementMode: Enum.DevTouchCameraMovementMode;
	/** [NO DOCUMENTATION] */
	DevTouchMovementMode: Enum.DevTouchMovementMode;
	/** [NO DOCUMENTATION] */
	EnableMouseLockOption: boolean;
	/** [NO DOCUMENTATION] */
	HealthDisplayDistance: number;
	/** [NO DOCUMENTATION] */
	LoadCharacterAppearance: boolean;
	/** [NO DOCUMENTATION] */
	NameDisplayDistance: number;
	/** [NO DOCUMENTATION] */
	readonly UserEmotesEnabled: boolean;
}

interface StarterPlayerScripts extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "StarterPlayerScripts" | "StarterCharacterScripts";
}

interface StarterCharacterScripts extends StarterPlayerScripts {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "StarterCharacterScripts";
}

interface Stats extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Stats";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly ContactsCount: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly DataReceiveKbps: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly DataSendKbps: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly HeartbeatTimeMs: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly InstanceCount: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly MovingPrimitivesCount: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly PhysicsReceiveKbps: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly PhysicsSendKbps: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly PhysicsStepTimeMs: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly PrimitivesCount: number;
	/** [NO DOCUMENTATION] */
	GetMemoryUsageMbForTag(tag: CastsToEnum<Enum.DeveloperMemoryTag>): number;
	/** [NO DOCUMENTATION] */
	GetTotalMemoryUsageMb(): number;
}

interface StatsItem extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "StatsItem" | "RunningAverageItemDouble" | "RunningAverageItemInt" | "RunningAverageTimeIntervalItem" | "TotalCountTimeIntervalItem";
}

interface RunningAverageItemDouble extends StatsItem {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RunningAverageItemDouble";
}

interface RunningAverageItemInt extends StatsItem {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RunningAverageItemInt";
}

interface RunningAverageTimeIntervalItem extends StatsItem {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RunningAverageTimeIntervalItem";
}

interface TotalCountTimeIntervalItem extends StatsItem {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TotalCountTimeIntervalItem";
}

interface StopWatchReporter extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "StopWatchReporter";
}

interface Studio extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Studio";
	["Always Save Script Changes"]: boolean;
	["Animate Hover Over"]: boolean;
	["Auto Indent"]: boolean;
	["Auto-Recovery Enabled"]: boolean;
	["Auto-Recovery Interval (Minutes)"]: number;
	["Auto-Recovery Path"]: QDir;
	["Background Color"]: Color3;
	["Basic Objects Display Mode"]: Enum.ListDisplayMode;
	["Built-in Function Color"]: Color3;
	["Camera Mouse Wheel Speed"]: number;
	["Camera Shift Speed"]: number;
	["Camera Speed"]: number;
	["Camera Zoom to Mouse Position"]: boolean;
	["Clear Output On Start"]: boolean;
	["Comment Color"]: Color3;
	DefaultScriptFileDir: QDir;
	DeprecatedObjectsShown: boolean;
	["Device Pairing Code"]: number;
	["Disable Accurate Play Solo"]: boolean;
	["Drag Multiple Parts As Single Part"]: boolean;
	["Enable Autocomplete"]: boolean;
	["Enable CoreScript Debugger"]: boolean;
	["Error Color"]: Color3;
	["Find Selection Background Color"]: Color3;
	Font: QFont;
	["Hover Animate Speed"]: Enum.HoverAnimateSpeed;
	["Hover Over Color"]: Color3;
	["Keyword Color"]: Color3;
	Language: Enum.LanguagePreference;
	["Line Thickness"]: number;
	LuaDebuggerEnabled: boolean;
	readonly LuaDebuggerEnabledAtStartup: boolean;
	["Matching Word Background Color"]: Color3;
	["Maximum Output Lines"]: number;
	["Number Color"]: Color3;
	["Only Play Audio from Window in Focus"]: boolean;
	["Operator Color"]: Color3;
	["Output Font"]: QFont;
	["Output Layout Mode"]: Enum.OutputLayoutMode;
	OverrideCoreScripts: boolean;
	OverrideCoreScriptsDir: QDir;
	PermissionLevelShown: Enum.PermissionLevelShown;
	PluginsDir: QDir;
	["Preprocessor Color"]: Color3;
	RecentSavesDir: QDir;
	["Render Throttle Percentage"]: number;
	["Respect Studio shortcuts when game has focus"]: boolean;
	RuntimeUndoBehavior: Enum.RuntimeUndoBehavior;
	ScriptTimeoutLength: number;
	["Select Color"]: Color3;
	["Select/Hover Color"]: Color3;
	["Selection Background Color"]: Color3;
	["Selection Color"]: Color3;
	["Server Audio Behavior"]: Enum.ServerAudioBehavior;
	["Show Core GUI in Explorer while Playing"]: boolean;
	["Show Diagnostics Bar"]: boolean;
	["Show Hidden Objects in Explorer"]: boolean;
	["Show Hover Over"]: boolean;
	["Show Navigation Mesh"]: boolean;
	["Show Plugin GUI Service in Explorer"]: boolean;
	["Show QT warnings in output"]: boolean;
	["Show Roblox Plugin GUI Service in Explorer"]: boolean;
	["Show plus button on hover in Explorer"]: boolean;
	["String Color"]: Color3;
	["Tab Width"]: number;
	["Text Color"]: Color3;
	["Text Wrapping"]: boolean;

	Theme: StudioTheme;
	readonly ["UI Theme"]: Enum.UITheme;
	["Warning Color"]: Color3;
}

interface StudioData extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "StudioData";
}

interface StudioService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "StudioService";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly ActiveScript?: Instance;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly StudioLocaleId: string;
}

interface StudioTheme extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "StudioTheme";
}

interface TaskScheduler extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TaskScheduler";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly SchedulerDutyCycle: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly SchedulerRate: number;
	/** [NO DOCUMENTATION] */
	ThreadPoolConfig: Enum.ThreadPoolConfig;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly ThreadPoolSize: number;
}

interface Team extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Team";
	AutoAssignable: boolean;
	TeamColor: BrickColor;

	GetPlayers(): Array<Player>;

	readonly PlayerAdded: RBXScriptSignal<(player: Player) => void>;

	readonly PlayerRemoved: RBXScriptSignal<(player: Player) => void>;
}

interface Teams extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Teams";

	GetTeams(): Array<Team>;
}

interface TeleportService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TeleportService";
	/** @rbxts client */
	GetArrivingTeleportGui(): ScreenGui | GuiMain | undefined;
	/** @rbxts client */
	GetLocalPlayerTeleportData(): unknown;
	/** @rbxts client */
	GetTeleportSetting(setting: string): unknown;
	/** @rbxts client */
	SetTeleportGui(gui: ScreenGui): void;
	/** @rbxts client */
	SetTeleportSetting(setting: string, value: TeleportData): void;

	Teleport(
		placeId: number,
		player?: Player,
		teleportData?: TeleportData,
		customLoadingScreen?: ScreenGui | GuiMain,
	): void;

	TeleportToPlaceInstance(
		placeId: number,
		instanceId: string,
		player?: Player,
		spawnName?: string,
		teleportData?: TeleportData,
		customLoadingScreen?: ScreenGui | GuiMain,
	): void;

	TeleportToPrivateServer(
		placeId: number,
		reservedServerAccessCode: string,
		players: Array<Player>,
		spawnName?: string,
		teleportData?: TeleportData,
		customLoadingScreen?: ScreenGui | GuiMain,
	): void;

	TeleportToSpawnByName(
		placeId: number,
		spawnName: string,
		player?: Player,
		teleportData?: any,
		customLoadingScreen?: ScreenGui | GuiMain,
	): void;
	/** @rbxts server */
	GetPlayerPlaceInstanceAsync(userId: number): LuaTuple<[boolean, string, number, string]>;
	/** @rbxts server */
	ReserveServer(placeId: number): LuaTuple<[string, string]>;

	TeleportPartyAsync(
		placeId: number,
		players: Array<Player>,
		teleportData?: TeleportData,
		customLoadingScreen?: ScreenGui | GuiMain,
	): string;

	readonly LocalPlayerArrivedFromTeleport: RBXScriptSignal<
		(loadingGui: ScreenGui | GuiMain, dataTable?: unknown) => void
	>;

	readonly TeleportInitFailed: RBXScriptSignal<
		(player: Player, teleportResult: Enum.TeleportResult, errorMessage: string) => void
	>;
}

interface TerrainRegion extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TerrainRegion";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly SizeInCells: Vector3;
}

interface TestService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TestService";
	/** [NO DOCUMENTATION] */
	AutoRuns: boolean;
	/** [NO DOCUMENTATION] */
	Description: string;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly ErrorCount: number;
	/** [NO DOCUMENTATION] */
	ExecuteWithStudioRun: boolean;
	/** [NO DOCUMENTATION] */
	Is30FpsThrottleEnabled: boolean;
	/** [NO DOCUMENTATION] */
	IsPhysicsEnvironmentalThrottled: boolean;
	/** [NO DOCUMENTATION] */
	IsSleepAllowed: boolean;
	/** [NO DOCUMENTATION] */
	NumberOfPlayers: number;
	/** [NO DOCUMENTATION] */
	SimulateSecondsLag: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly TestCount: number;
	/** [NO DOCUMENTATION] */
	Timeout: number;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly WarnCount: number;
	/** [NO DOCUMENTATION] */
	Check(condition: boolean, description: string, source?: Instance, line?: number): void;
	/** [NO DOCUMENTATION] */
	Checkpoint(text: string, source?: Instance, line?: number): void;
	/** [NO DOCUMENTATION] */
	Done(): void;
	/** [NO DOCUMENTATION] */
	Error(description: string, source?: Instance, line?: number): void;
	/** [NO DOCUMENTATION] */
	Fail(description: string, source?: Instance, line?: number): void;
	/** [NO DOCUMENTATION] */
	Message(text: string, source?: Instance, line?: number): void;
	/** [NO DOCUMENTATION] */
	Require(condition: boolean, description: string, source?: Instance, line?: number): void;
	/** [NO DOCUMENTATION] */
	Warn(condition: boolean, description: string, source?: Instance, line?: number): void;
	/** [NO DOCUMENTATION] */
	isFeatureEnabled(name: string): boolean;
	/** [NO DOCUMENTATION] */
	readonly ServerCollectConditionalResult: RBXScriptSignal<(condition: boolean, text: string, script: Instance, line: number) => void>;
	/** [NO DOCUMENTATION] */
	readonly ServerCollectResult: RBXScriptSignal<(text: string, script: Instance, line: number) => void>;
}

interface TextFilterResult extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TextFilterResult";
	/** [NO DOCUMENTATION] *
	 * Tags: Yields
	 */
	GetChatForUserAsync(toUserId: number): string;
	/** [NO DOCUMENTATION] *
	 * Tags: Yields
	 */
	GetNonChatStringForBroadcastAsync(): string;
	/** [NO DOCUMENTATION] *
	 * Tags: Yields
	 */
	GetNonChatStringForUserAsync(toUserId: number): string;
}

interface TextService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TextService";
	GetTextSize(string: string, fontSize: number, font: CastsToEnum<Enum.Font>, frameSize: Vector2): Vector2;
	/** @rbxts server */
	FilterStringAsync(
		stringToFilter: string,
		fromUserId: number,
		textContext?: CastsToEnum<Enum.TextFilterContext>,
	): TextFilterResult | undefined;
}

interface ThirdPartyUserService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ThirdPartyUserService";
}

interface TimerService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TimerService";
}

interface TouchInputService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TouchInputService";
}

interface TouchTransmitter extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TouchTransmitter";
}

interface Trail extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Trail";
	/** [NO DOCUMENTATION] */
	Attachment0?: Attachment;
	/** [NO DOCUMENTATION] */
	Attachment1?: Attachment;
	/** [NO DOCUMENTATION] */
	Color: ColorSequence;
	/** [NO DOCUMENTATION] */
	Enabled: boolean;
	/** [NO DOCUMENTATION] */
	FaceCamera: boolean;
	/** [NO DOCUMENTATION] */
	Lifetime: number;
	/** [NO DOCUMENTATION] */
	LightEmission: number;
	/** [NO DOCUMENTATION] */
	LightInfluence: number;
	/** [NO DOCUMENTATION] */
	MaxLength: number;
	/** [NO DOCUMENTATION] */
	MinLength: number;
	/** [NO DOCUMENTATION] */
	Texture: string;
	/** [NO DOCUMENTATION] */
	TextureLength: number;
	/** [NO DOCUMENTATION] */
	TextureMode: Enum.TextureMode;
	/** [NO DOCUMENTATION] */
	Transparency: NumberSequence;
	/** [NO DOCUMENTATION] */
	WidthScale: NumberSequence;
	/** [NO DOCUMENTATION] */
	Clear(): void;
}

interface Translator extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Translator";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly LocaleId: string;
	/** [NO DOCUMENTATION] */
	FormatByKey(key: string, args?: any): string;
	/** [NO DOCUMENTATION] */
	Translate(context: Instance, text: string): string;
}

interface TweenBase extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TweenBase" | "Tween";
	/** The current state of how the tween is animating. Possible values are Begin, Playing, Paused, Completed and Cancelled. This property is modified by using functions such as Tween:Play(), Tween:Pause(), and Tween:Cancel(). Read-only.The current state of how the tween is animating. Possible values are Begin, Playing, Paused, Completed and Cancelled. This property is modified by using functions such as Tween:Play(), Tween:Pause(), and Tween:Cancel(). Read-only. *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly PlaybackState: Enum.PlaybackState;
	/** Stops the tween animation. Animation can be restarted by calling Play(). Animation will start from the beginning values. */
	Cancel(): void;
	/** Temporarily stops the tween animation. Animation can be resumed by calling Play(). */
	Pause(): void;
	/** Starts or resumes (if Tween.PlaybackState is Paused) the tween animation. If current PlaybackState is Cancelled, this property will reset the tween to the beginning properties and play the animations from the beginning. */
	Play(): void;
	/** Fires when the tween either reaches PlaybackState Completed or Cancelled. PlaybackState of one of these types is passed as the first arg to the function listening to this event. */
	readonly Completed: RBXScriptSignal<(playbackState: Enum.PlaybackState) => void>;
}

interface Tween extends TweenBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Tween";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Instance?: Instance;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly TweenInfo: TweenInfo;
}

interface TweenService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "TweenService";

	Create<T extends Instances[keyof Instances]>(
		instance: T,
		tweenInfo: TweenInfo,
		propertyTable: Partial<FilterMembers<T, Tweenable>>,
	): Tween;
	GetValue(alpha: number, easingStyle: CastsToEnum<Enum.EasingStyle>, easingDirection: CastsToEnum<Enum.EasingDirection>): number;
}

interface UIBase extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UIBase" | "UIComponent" | "UIConstraint" | "UILayout" | "UIPadding" | "UIScale" | "UIAspectRatioConstraint" | "UISizeConstraint" | "UITextSizeConstraint" | "UIGridStyleLayout" | "UIGridLayout" | "UIInlineLayout" | "UIListLayout" | "UIPageLayout" | "UITableLayout";
}

interface UIComponent extends UIBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UIComponent" | "UIConstraint" | "UILayout" | "UIPadding" | "UIScale" | "UIAspectRatioConstraint" | "UISizeConstraint" | "UITextSizeConstraint" | "UIGridStyleLayout" | "UIGridLayout" | "UIInlineLayout" | "UIListLayout" | "UIPageLayout" | "UITableLayout";
}

interface UIConstraint extends UIComponent {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UIConstraint" | "UIAspectRatioConstraint" | "UISizeConstraint" | "UITextSizeConstraint";
}

interface UIAspectRatioConstraint extends UIConstraint {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UIAspectRatioConstraint";
	/** The aspect ratio to maintain. This is the width/height. Only positive numbers allowed. */
	AspectRatio: number;
	/** Describes how the aspect ratio will determine its size. Options are FitWithinMaxSize, ScaleWithParentSize. FitWithinMaxSize will make the element the maximum size it can be within the current possible AbsoluteSize of the element while maintaining the AspectRatio. ScaleWithParentSize will make the element the closest to the parent element’s maximum size while maintaining aspect ratio. */
	AspectType: Enum.AspectType;
	/** Describes which axis to use when determining the new size of the element, while keeping respect to the aspect ratio. */
	DominantAxis: Enum.DominantAxis;
}

interface UISizeConstraint extends UIConstraint {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UISizeConstraint";
	/** The biggest size the GuiObject is allowed to be. */
	MaxSize: Vector2;
	/** The smallest size the GuiObject is allowed to be. */
	MinSize: Vector2;
}

interface UITextSizeConstraint extends UIConstraint {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UITextSizeConstraint";
	/** The biggest size the font is allowed to be. */
	MaxTextSize: number;
	/** The smallest size the font is allowed to be. */
	MinTextSize: number;
}

interface UILayout extends UIComponent {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UILayout" | "UIGridStyleLayout" | "UIGridLayout" | "UIInlineLayout" | "UIListLayout" | "UIPageLayout" | "UITableLayout";
}

interface UIGridStyleLayout extends UILayout {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UIGridStyleLayout" | "UIGridLayout" | "UIInlineLayout" | "UIListLayout" | "UIPageLayout" | "UITableLayout";
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly AbsoluteContentSize: Vector2;
	/** Determines which direction to fill the grid. Can be Horizontal or Vertical. */
	FillDirection: Enum.FillDirection;
	/** Determines how grid is placed within it's parent's container in the x direction. Can be Left, Center, or Right. */
	HorizontalAlignment: Enum.HorizontalAlignment;
	/** Determines how we decide which element to place next. Can be Name or Custom. If using Custom, make sure SetCustomSortFunction was called with an appropriate sort function. */
	SortOrder: Enum.SortOrder;
	/** Determines how grid is placed within it's parent's container in the y direction. Can be Top, Center, or Bottom. */
	VerticalAlignment: Enum.VerticalAlignment;
}

interface UIGridLayout extends UIGridStyleLayout {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UIGridLayout";
	/** How much space between elements there should be. */
	CellPadding: UDim2;
	/** Denotes what size each element should be. Can be overridden by elements using constraints on individual elements. */
	CellSize: UDim2;
	/** Determines how many cells over in the FillDirection we go before starting a new row or column. Set to 0 for max cell count.  Will be clamped if this is set higher than the parent container allows room for. */
	FillDirectionMaxCells: number;
	/** Which corner we start laying the elements out from. Can be TopLeft, TopRight, BottomLeft, BottomRight. */
	StartCorner: Enum.StartCorner;
}

interface UIInlineLayout extends UIGridStyleLayout {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UIInlineLayout";
	/** [NO DOCUMENTATION] */
	InlineAlignment: Enum.InlineAlignment;
}

interface UIListLayout extends UIGridStyleLayout {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UIListLayout";
	/** Determines the amount of free space between each element. Can be set either using scale (Percentage of parent's size in the current direction) or offset (a static spacing value, similar to pixel size). */
	Padding: UDim;
}

interface UIPageLayout extends UIGridStyleLayout {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UIPageLayout";
	/** Whether or not to animate transitions between pages. */
	Animated: boolean;
	/** Whether or not the page layout wraps around at the ends. */
	Circular: boolean;
	/** The page that is either currently being displayed or is the target of the current animation. */
	readonly CurrentPage?: GuiObject;
	/** The easing direction to use when performing an animation. */
	EasingDirection: Enum.EasingDirection;
	/** The easing style to use when performing an animation. */
	EasingStyle: Enum.EasingStyle;
	GamepadInputEnabled: boolean;
	/** Determines the amount that pages are separated from each other by. Can be set either using scale (Percentage of parent's size in the current direction) or offset (a static spacing value, similar to pixel size). */
	Padding: UDim;
	ScrollWheelInputEnabled: boolean;
	TouchInputEnabled: boolean;
	/** The length of the animation. */
	TweenTime: number;
	/** If the instance is in the layout, then it sets CurrentPage to it and animtes to it. If circular layout is set, it will take the shortest path. */
	JumpTo(page: GuiObject): void;
	/** If the index is >= 0 and less than the size of the layout, acts like JumpTo. If it's out of bounds and circular is set, it will animate the full distance between the in-bounds index of CurrentPage and the new index. */
	JumpToIndex(index: number): void;
	/** Sets CurrentPage to the page after the current page and animates to it, or does nothing if there isn't a next page. */
	Next(): void;
	/** Sets CurrentPage to the page after the current page and animates to it, or does nothing if there isn't a next page. */
	Previous(): void;
	/** Fires when a page comes into view, and is going to be rendered. */
	readonly PageEnter: RBXScriptSignal<(page: GuiObject) => void>;
	/** Fires when a page leaves view, and will not be rendered. */
	readonly PageLeave: RBXScriptSignal<(page: GuiObject) => void>;
	/** Fires when an animation to CurrentPage is completed without being cancelled, and the view stops scrolling. */
	readonly Stopped: RBXScriptSignal<(currentPage: GuiObject) => void>;
}

interface UITableLayout extends UIGridStyleLayout {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UITableLayout";
	/** Whether the table should expand to fill the available space of its container, column-wise. */
	FillEmptySpaceColumns: boolean;
	/** Whether the table should expand to fill the available space of its container, row-wise. */
	FillEmptySpaceRows: boolean;
	/** Whether the direct siblings are considered the rows or the columns. The children of the direct siblings are the columns or rows, respectively. */
	MajorAxis: Enum.TableMajorAxis;
	/** The amount of padding to insert in between the cells of the table. */
	Padding: UDim2;
}

interface UIPadding extends UIComponent {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UIPadding";
	/** The padding to apply on the bottom side relative to the parent's normal size. */
	PaddingBottom: UDim;
	/** The padding to apply on the left side relative to the parent's normal size. */
	PaddingLeft: UDim;
	/** The padding to apply on the right side relative to the parent's normal size. */
	PaddingRight: UDim;
	/** The padding to apply on the top side relative to the parent's normal size. */
	PaddingTop: UDim;
}

interface UIScale extends UIComponent {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UIScale";
	/** The scale factor to apply. */
	Scale: number;
}

interface UserGameSettings extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UserGameSettings";
	/** [NO DOCUMENTATION] */
	ComputerCameraMovementMode: Enum.ComputerCameraMovementMode;
	/** [NO DOCUMENTATION] */
	ComputerMovementMode: Enum.ComputerMovementMode;
	/** [NO DOCUMENTATION] */
	ControlMode: Enum.ControlMode;
	/** [NO DOCUMENTATION] */
	GamepadCameraSensitivity: number;
	/** [NO DOCUMENTATION] */
	MasterVolume: number;
	/** [NO DOCUMENTATION] */
	MouseSensitivity: number;
	/** [NO DOCUMENTATION] */
	RCCProfilerRecordFrameRate: number;
	/** [NO DOCUMENTATION] */
	RCCProfilerRecordTimeFrame: number;
	/** [NO DOCUMENTATION] */
	RotationType: Enum.RotationType;
	/** [NO DOCUMENTATION] */
	SavedQualityLevel: Enum.SavedQualitySetting;
	/** [NO DOCUMENTATION] */
	TouchCameraMovementMode: Enum.TouchCameraMovementMode;
	/** [NO DOCUMENTATION] */
	TouchMovementMode: Enum.TouchMovementMode;
	/** [NO DOCUMENTATION] */
	GetCameraYInvertValue(): number;
	/** [NO DOCUMENTATION] */
	GetOnboardingCompleted(onboardingId: string): boolean;
	/** [NO DOCUMENTATION] */
	InFullScreen(): boolean;
	/** [NO DOCUMENTATION] */
	InStudioMode(): boolean;
	/** [NO DOCUMENTATION] */
	SetCameraYInvertVisible(): void;
	/** [NO DOCUMENTATION] */
	SetGamepadCameraSensitivityVisible(): void;
	/** [NO DOCUMENTATION] */
	SetOnboardingCompleted(onboardingId: string): void;
	/** [NO DOCUMENTATION] */
	readonly FullscreenChanged: RBXScriptSignal<(isFullscreen: boolean) => void>;
	/** [NO DOCUMENTATION] */
	readonly StudioModeChanged: RBXScriptSignal<(isStudioMode: boolean) => void>;
}

/** @rbxts client */
interface UserInputService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "UserInputService";
	/** Returns true if the local device has an accelerometer, false otherwise. */
	readonly AccelerometerEnabled: boolean;
	readonly GamepadEnabled: boolean;
	/** Returns true if the local device has an gyroscope, false otherwise. */
	readonly GyroscopeEnabled: boolean;
	/** Returns true if the local device accepts keyboard input, false otherwise. */
	readonly KeyboardEnabled: boolean;
	ModalEnabled: boolean;
	MouseBehavior: Enum.MouseBehavior;
	MouseDeltaSensitivity: number;
	/** Returns true if the local device accepts mouse input, false otherwise. */
	readonly MouseEnabled: boolean;
	MouseIconEnabled: boolean;
	readonly OnScreenKeyboardPosition: Vector2;
	readonly OnScreenKeyboardSize: Vector2;
	readonly OnScreenKeyboardVisible: boolean;
	/** Returns true if the local device accepts touch input, false otherwise. */
	readonly TouchEnabled: boolean;
	readonly VREnabled: boolean;
	GamepadSupports(gamepadNum: CastsToEnum<Enum.UserInputType>, gamepadKeyCode: CastsToEnum<Enum.KeyCode>): boolean;

	GetConnectedGamepads(): Array<Enum.UserInputType>;
	/** Returns an InputObject that describes the device's current acceleration. This is fired with an InputObject, which has type Enum.InputType.Accelerometer, and position that shows the g force in each local device axis.  The delta property describes the amount of rotation that last happened. This event only fires locally. */
	GetDeviceAcceleration(): InputObject;
	/** Returns an InputObject that describes the device's current gravity vector. This is fired with an InputObject, which has type Enum.InputType.Accelerometer, and position that shows the g force in each local device axis. The delta property describes the amount of rotation that last happened. This event only fires locally. */
	GetDeviceGravity(): InputObject;
	/** Returns an InputObject and a Vector4 that describes the device's current rotation vector. This is fired with an InputObject, which has type Enum.InputType.Gyroscope, and position that shows total rotation in each local device axis. The delta property describes the amount of rotation that last happened. The Vector4 is the device's current quaternion rotation in reference to it's default reference frame. This event only fires locally. */
	GetDeviceRotation(): LuaTuple<[InputObject, CFrame]>;

	GetFocusedTextBox(): TextBox | undefined;
	GetGamepadConnected(gamepadNum: CastsToEnum<Enum.UserInputType>): boolean;

	GetGamepadState(gamepadNum: CastsToEnum<Enum.UserInputType>): Array<InputObject>;

	GetKeysPressed(): Array<InputObject>;
	GetLastInputType(): Enum.UserInputType;

	GetMouseButtonsPressed(): Array<InputObject>;
	GetMouseDelta(): Vector2;
	GetMouseLocation(): Vector2;

	GetNavigationGamepads(): Array<Enum.UserInputType>;
	GetStringForKeyCode(keyCode: CastsToEnum<Enum.KeyCode>): string;

	GetSupportedGamepadKeyCodes(gamepadNum: CastsToEnum<Enum.UserInputType>): Array<Enum.KeyCode>;
	GetUserCFrame(type: CastsToEnum<Enum.UserCFrame>): CFrame;
	IsGamepadButtonDown(gamepadNum: CastsToEnum<Enum.UserInputType>, gamepadKeyCode: CastsToEnum<Enum.KeyCode>): boolean;
	IsKeyDown(keyCode: CastsToEnum<Enum.KeyCode>): boolean;
	IsMouseButtonPressed(mouseButton: CastsToEnum<Enum.UserInputType>): boolean;
	IsNavigationGamepad(gamepadEnum: CastsToEnum<Enum.UserInputType>): boolean;
	RecenterUserHeadCFrame(): void;
	SetNavigationGamepad(gamepadEnum: CastsToEnum<Enum.UserInputType>, enabled: boolean): void;
	/** Fired when a user moves a device that has an accelerometer. This is fired with an InputObject, which has type Enum.InputType.Accelerometer, and position that shows the g force in each local device axis. This event only fires locally. */
	readonly DeviceAccelerationChanged: RBXScriptSignal<(acceleration: InputObject) => void>;
	/** Fired when the force of gravity changes on a device that has an accelerometer. This is fired with an InputObject, which has type Enum.InputType.Accelerometer, and position that shows the g force in each local device axis. This event only fires locally. */
	readonly DeviceGravityChanged: RBXScriptSignal<(gravity: InputObject) => void>;
	/** Fired when a user rotates a device that has an gyroscope. This is fired with an InputObject, which has type Enum.InputType.Gyroscope, and position that shows total rotation in each local device axis.  The delta property describes the amount of rotation that last happened. A second argument of Vector4 is the device's current quaternion rotation in reference to it's default reference frame. This event only fires locally. */
	readonly DeviceRotationChanged: RBXScriptSignal<(rotation: InputObject, cframe: CFrame) => void>;
	readonly GamepadConnected: RBXScriptSignal<(gamepadNum: Enum.UserInputType) => void>;
	readonly GamepadDisconnected: RBXScriptSignal<(gamepadNum: Enum.UserInputType) => void>;
	/** Fired when a user begins interacting via a Human-Computer Interface device (Mouse button down, touch begin, keyboard button down, etc.). 'inputObject' is an InputObject, which contains useful data for querying user input.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly InputBegan: RBXScriptSignal<(input: InputObject, gameProcessedEvent: boolean) => void>;
	/** Fired when a user changes interacting via a Human-Computer Interface device (Mouse move, touch move, mouse wheel, etc.). 'inputObject' is an InputObject, which contains useful data for querying user input.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly InputChanged: RBXScriptSignal<(input: InputObject, gameProcessedEvent: boolean) => void>;
	/** Fired when a user stops interacting via a Human-Computer Interface device (Mouse button up, touch end, keyboard button up, etc.). 'inputObject' is an InputObject, which contains useful data for querying user input.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly InputEnded: RBXScriptSignal<(input: InputObject, gameProcessedEvent: boolean) => void>;
	readonly JumpRequest: RBXScriptSignal<() => void>;
	readonly LastInputTypeChanged: RBXScriptSignal<(lastInputType: Enum.UserInputType) => void>;
	/** Fired when a user stops text entry into a textbox (usually by pressing return or clicking/tapping somewhere else on the screen). Argument is the textbox that was taken out of focus. This event only fires locally. */
	readonly TextBoxFocusReleased: RBXScriptSignal<(textboxReleased: TextBox) => void>;
	/** Fired when a user clicks/taps on a textbox to begin text entry. Argument is the textbox that was put in focus. This also fires if a textbox forces focus on the user. This event only fires locally. */
	readonly TextBoxFocused: RBXScriptSignal<(textboxFocused: TextBox) => void>;
	/** Fired when a user moves their finger on a TouchEnabled device. 'touch' is an InputObject, which contains useful data for querying user input.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchEnded: RBXScriptSignal<(touch: InputObject, gameProcessedEvent: boolean) => void>;
	/** Fired when a user holds at least one finger for a short amount of time on the same screen position on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the gesture. 'state' indicates the Enum.UserInputState of the gesture.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchLongPress: RBXScriptSignal<
		(touchPositions: Array<InputObject>, state: Enum.UserInputState, gameProcessedEvent: boolean) => void
	>;
	/** Fired when a user moves their finger on a TouchEnabled device. 'touch' is an InputObject, which contains useful data for querying user input.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchMoved: RBXScriptSignal<(touch: InputObject, gameProcessedEvent: boolean) => void>;
	/** Fired when a user drags at least one finger on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the gesture. 'totalTranslation' is a Vector2, indicating how far the pan gesture has gone from its starting point. 'velocity' is a Vector2 that indicates how quickly the gesture is being performed in each dimension. 'state' indicates the Enum.UserInputState of the gesture.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchPan: RBXScriptSignal<
		(
			touchPositions: Array<InputObject>,
			totalTranslation: Vector2,
			velocity: Vector2,
			state: Enum.UserInputState,
			gameProcessedEvent: boolean,
		) => void
	>;
	/** Fired when a user pinches their fingers on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the pinch gesture. 'scale' is a float that indicates the difference from the beginning of the pinch gesture. 'velocity' is a float indicating how quickly the pinch gesture is happening. 'state' indicates the Enum.UserInputState of the gesture.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchPinch: RBXScriptSignal<
		(
			touchPositions: Array<InputObject>,
			scale: number,
			velocity: number,
			state: Enum.UserInputState,
			gameProcessedEvent: boolean,
		) => void
	>;
	/** Fired when a user rotates two fingers on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the gesture. 'rotation' is a float indicating how much the rotation has gone from the start of the gesture. 'velocity' is a float that indicates how quickly the gesture is being performed. 'state' indicates the Enum.UserInputState of the gesture.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchRotate: RBXScriptSignal<
		(
			touchPositions: Array<InputObject>,
			rotation: number,
			velocity: number,
			state: Enum.UserInputState,
			gameProcessedEvent: boolean,
		) => void
	>;
	/** Fired when a user places their finger on a TouchEnabled device. 'touch' is an InputObject, which contains useful data for querying user input.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchStarted: RBXScriptSignal<(touch: InputObject, gameProcessedEvent: boolean) => void>;
	/** Fired when a user swipes their fingers on a TouchEnabled device. 'swipeDirection' is an Enum.SwipeDirection, indicating the direction the user swiped. 'numberOfTouches' is an int that indicates how many touches were involved with the gesture.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchSwipe: RBXScriptSignal<(swipeDirection: Enum.SwipeDirection, numberOfTouches: number, gameProcessedEvent: boolean) => void>;
	/** Fired when a user taps their finger on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the tap gesture. This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchTap: RBXScriptSignal<(touchPositions: Array<InputObject>, gameProcessedEvent: boolean) => void>;
	readonly TouchTapInWorld: RBXScriptSignal<(position: Vector2, processedByUI: boolean) => void>;
	readonly UserCFrameChanged: RBXScriptSignal<(type: Enum.UserCFrame, value: CFrame) => void>;
	readonly WindowFocusReleased: RBXScriptSignal<() => void>;
	readonly WindowFocused: RBXScriptSignal<() => void>;
}

interface VRService extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "VRService";
	/** [NO DOCUMENTATION] */
	GuiInputUserCFrame: Enum.UserCFrame;
	/** [NO DOCUMENTATION] *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly VREnabled: boolean;
	/** [NO DOCUMENTATION] */
	GetTouchpadMode(pad: CastsToEnum<Enum.VRTouchpad>): Enum.VRTouchpadMode;
	/** [NO DOCUMENTATION] */
	GetUserCFrame(type: CastsToEnum<Enum.UserCFrame>): CFrame;
	/** [NO DOCUMENTATION] */
	GetUserCFrameEnabled(type: CastsToEnum<Enum.UserCFrame>): boolean;
	/** [NO DOCUMENTATION] */
	RecenterUserHeadCFrame(): void;
	/** [NO DOCUMENTATION] */
	RequestNavigation(cframe: CFrame, inputUserCFrame: CastsToEnum<Enum.UserCFrame>): void;
	/** [NO DOCUMENTATION] */
	SetTouchpadMode(pad: CastsToEnum<Enum.VRTouchpad>, mode: CastsToEnum<Enum.VRTouchpadMode>): void;
	/** [NO DOCUMENTATION] */
	readonly NavigationRequested: RBXScriptSignal<(cframe: CFrame, inputUserCFrame: Enum.UserCFrame) => void>;
	/** [NO DOCUMENTATION] */
	readonly TouchpadModeChanged: RBXScriptSignal<(pad: Enum.VRTouchpad, mode: Enum.VRTouchpadMode) => void>;
	/** [NO DOCUMENTATION] */
	readonly UserCFrameChanged: RBXScriptSignal<(type: Enum.UserCFrame, value: CFrame) => void>;
	/** [NO DOCUMENTATION] */
	readonly UserCFrameEnabled: RBXScriptSignal<(type: Enum.UserCFrame, enabled: boolean) => void>;
}

/**
 * Used to hold a value.
 */
interface ValueBase extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ValueBase" | "BinaryStringValue" | "BoolValue" | "BrickColorValue" | "CFrameValue" | "Color3Value" | "DoubleConstrainedValue" | "IntConstrainedValue" | "IntValue" | "NumberValue" | "ObjectValue" | "RayValue" | "StringValue" | "Vector3Value";
}

interface BinaryStringValue extends ValueBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BinaryStringValue";
	/** [NO DOCUMENTATION] */
	readonly Changed: RBXScriptSignal<(value: null) => void>;
}

interface BoolValue extends ValueBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BoolValue";
	/** [NO DOCUMENTATION] */
	Value: boolean;
	/** [NO DOCUMENTATION] */
	readonly Changed: RBXScriptSignal<(value: boolean) => void>;
}

interface BrickColorValue extends ValueBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "BrickColorValue";
	/** [NO DOCUMENTATION] */
	Value: BrickColor;
	/** [NO DOCUMENTATION] */
	readonly Changed: RBXScriptSignal<(value: BrickColor) => void>;
}

interface CFrameValue extends ValueBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "CFrameValue";
	/** [NO DOCUMENTATION] */
	Value: CFrame;
	/** [NO DOCUMENTATION] */
	readonly Changed: RBXScriptSignal<(value: CFrame) => void>;
}

interface Color3Value extends ValueBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Color3Value";
	/** [NO DOCUMENTATION] */
	Value: Color3;
	/** [NO DOCUMENTATION] */
	readonly Changed: RBXScriptSignal<(value: Color3) => void>;
}

interface DoubleConstrainedValue extends ValueBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "DoubleConstrainedValue";
	/** [NO DOCUMENTATION] *
	 * Tags: Hidden, NotReplicated
	 */
	ConstrainedValue: number;
	/** The maximum we allow this Value to be set.  If Value is set higher than this, it automatically gets adjusted to MaxValue */
	MaxValue: number;
	/** The minimum we allow this Value to be set.  If Value is set lower than this, it automatically gets adjusted to MinValue */
	MinValue: number;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	Value: number;
	/** [NO DOCUMENTATION] */
	readonly Changed: RBXScriptSignal<(value: number) => void>;
}

interface IntConstrainedValue extends ValueBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "IntConstrainedValue";
	/** [NO DOCUMENTATION] *
	 * Tags: Hidden, NotReplicated
	 */
	ConstrainedValue: number;
	/** [NO DOCUMENTATION] */
	MaxValue: number;
	/** [NO DOCUMENTATION] */
	MinValue: number;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	Value: number;
	/** [NO DOCUMENTATION] */
	readonly Changed: RBXScriptSignal<(value: number) => void>;
}

interface IntValue extends ValueBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "IntValue";
	/** [NO DOCUMENTATION] */
	Value: number;
	/** [NO DOCUMENTATION] */
	readonly Changed: RBXScriptSignal<(value: number) => void>;
}

interface NumberValue extends ValueBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "NumberValue";
	/** [NO DOCUMENTATION] */
	Value: number;
	/** [NO DOCUMENTATION] */
	readonly Changed: RBXScriptSignal<(value: number) => void>;
}

interface ObjectValue extends ValueBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "ObjectValue";
	Value?: Instance;

	readonly Changed: RBXScriptSignal<(value?: Instance) => void>;
}

interface RayValue extends ValueBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "RayValue";
	/** [NO DOCUMENTATION] */
	Value: Ray;
	/** [NO DOCUMENTATION] */
	readonly Changed: RBXScriptSignal<(value: Ray) => void>;
}

interface StringValue extends ValueBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "StringValue";
	/** [NO DOCUMENTATION] */
	Value: string;
	/** [NO DOCUMENTATION] */
	readonly Changed: RBXScriptSignal<(value: string) => void>;
}

interface Vector3Value extends ValueBase {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Vector3Value";
	/** [NO DOCUMENTATION] */
	Value: Vector3;
	/** [NO DOCUMENTATION] */
	readonly Changed: RBXScriptSignal<(value: Vector3) => void>;
}

interface VirtualInputManager extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "VirtualInputManager";
}

interface VirtualUser extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "VirtualUser";
}

interface Visit extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "Visit";
}

interface WeldConstraint extends Instance {
	/** A read-only string representing the class this Instance belongs to. `classIs()` can be used to check if this instance belongs to a specific class, ignoring class inheritance. */
	readonly ClassName: "WeldConstraint";
	/** Read-only boolean, true if the joint is active in world. Rigid joints may be inactive if they are redundant or form cycles.Read-only boolean, true if the joint is active in world. Rigid joints may be inactive if they are redundant or form cycles. *
	 * Tags: ReadOnly, NotReplicated
	 */
	readonly Active: boolean;
	/** [NO DOCUMENTATION] */
	Enabled: boolean;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	Part0?: BasePart;
	/** [NO DOCUMENTATION] *
	 * Tags: NotReplicated
	 */
	Part1?: BasePart;
}

